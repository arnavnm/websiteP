{"ast":null,"code":"import { Slot as e } from \"@radix-ui/react-slot\";\nimport { useComposedRefs as r } from \"@radix-ui/react-compose-refs\";\nimport { createContextScope as t } from \"@radix-ui/react-context\";\nimport o from \"react\";\nexport function createCollection(c) {\n  const n = c + \"CollectionProvider\",\n        [l, i] = t(n),\n        [f, a] = l(n, {\n    collectionRef: {\n      current: null\n    },\n    itemMap: new Map()\n  }),\n        u = e => {\n    const {\n      scope: r,\n      children: t\n    } = e,\n          c = o.useRef(null),\n          n = o.useRef(new Map()).current;\n    /*#__PURE__*/\n\n    return o.createElement(f, {\n      scope: r,\n      itemMap: n,\n      collectionRef: c\n    }, t);\n  },\n        m = c + \"CollectionSlot\",\n        s = /*#__PURE__*/o.forwardRef((t, c) => {\n    const {\n      scope: n,\n      children: l\n    } = t,\n          i = a(m, n),\n          f = r(c, i.collectionRef);\n    /*#__PURE__*/\n\n    return o.createElement(e, {\n      ref: f\n    }, l);\n  }),\n        p = c + \"CollectionItemSlot\",\n        d = \"data-radix-collection-item\",\n        R = /*#__PURE__*/o.forwardRef((t, c) => {\n    const {\n      scope: n,\n      children: l,\n      ...i\n    } = t,\n          f = o.useRef(null),\n          u = r(c, f),\n          m = a(p, n);\n    return o.useEffect(() => (m.itemMap.set(f, {\n      ref: f,\n      ...i\n    }), () => {\n      m.itemMap.delete(f);\n    })), /*#__PURE__*/o.createElement(e, {\n      [d]: \"\",\n      ref: u\n    }, l);\n  });\n\n  return [{\n    Provider: u,\n    Slot: s,\n    ItemSlot: R\n  }, function (e) {\n    const r = a(c + \"CollectionConsumer\", e);\n    return o.useCallback(() => {\n      const e = r.collectionRef.current;\n      if (!e) return [];\n      const t = Array.from(e.querySelectorAll(`[${d}]`));\n      return Array.from(r.itemMap.values()).sort((e, r) => t.indexOf(e.ref.current) - t.indexOf(r.ref.current));\n    }, [r.collectionRef, r.itemMap]);\n  }, i];\n}","map":{"version":3,"mappings":"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","names":["createCollection","name","PROVIDER_NAME","createCollectionContext","createCollectionScope","createContextScope","CollectionProviderImpl","useCollectionContext","collectionRef","current","itemMap","Map","CollectionProvider","props","scope","children","ref","React","useRef","_react","COLLECTION_SLOT_NAME","CollectionSlot","forwardRef","forwardedRef","context","composedRefs","useComposedRefs","Slot","ITEM_SLOT_NAME","ITEM_DATA_ATTR","CollectionItemSlot","itemData","useEffect","set","delete","Provider","ItemSlot","useCallback","collectionNode","orderedNodes","Array","from","querySelectorAll","values","sort","a","b","indexOf"],"sources":["/Users/arnavmisra/Desktop/Portfolio-main/node_modules/@radix-ui/react-collection/dist/packages/react/collection/src/Collection.tsx"],"sourcesContent":["import React from 'react';\nimport { createContextScope } from '@radix-ui/react-context';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { Slot } from '@radix-ui/react-slot';\n\nimport type * as Radix from '@radix-ui/react-primitive';\n\ntype SlotProps = Radix.ComponentPropsWithoutRef<typeof Slot>;\ntype CollectionElement = HTMLElement;\ninterface CollectionProps extends SlotProps {\n  scope: any;\n}\n\n// We have resorted to returning slots directly rather than exposing primitives that can then\n// be slotted like `<CollectionItem as={Slot}>â€¦</CollectionItem>`.\n// This is because we encountered issues with generic types that cannot be statically analysed\n// due to creating them dynamically via createCollection.\n\nfunction createCollection<ItemElement extends HTMLElement, ItemData = {}>(name: string) {\n  /* -----------------------------------------------------------------------------------------------\n   * CollectionProvider\n   * ---------------------------------------------------------------------------------------------*/\n\n  const PROVIDER_NAME = name + 'CollectionProvider';\n  const [createCollectionContext, createCollectionScope] = createContextScope(PROVIDER_NAME);\n\n  type ContextValue = {\n    collectionRef: React.RefObject<CollectionElement>;\n    itemMap: Map<React.RefObject<ItemElement>, { ref: React.RefObject<ItemElement> } & ItemData>;\n  };\n\n  const [CollectionProviderImpl, useCollectionContext] = createCollectionContext<ContextValue>(\n    PROVIDER_NAME,\n    { collectionRef: { current: null }, itemMap: new Map() }\n  );\n\n  const CollectionProvider: React.FC<{ scope: any }> = (props) => {\n    const { scope, children } = props;\n    const ref = React.useRef<CollectionElement>(null);\n    const itemMap = React.useRef<ContextValue['itemMap']>(new Map()).current;\n    return (\n      <CollectionProviderImpl scope={scope} itemMap={itemMap} collectionRef={ref}>\n        {children}\n      </CollectionProviderImpl>\n    );\n  };\n\n  CollectionProvider.displayName = PROVIDER_NAME;\n\n  /* -----------------------------------------------------------------------------------------------\n   * CollectionSlot\n   * ---------------------------------------------------------------------------------------------*/\n\n  const COLLECTION_SLOT_NAME = name + 'CollectionSlot';\n\n  const CollectionSlot = React.forwardRef<CollectionElement, CollectionProps>(\n    (props, forwardedRef) => {\n      const { scope, children } = props;\n      const context = useCollectionContext(COLLECTION_SLOT_NAME, scope);\n      const composedRefs = useComposedRefs(forwardedRef, context.collectionRef);\n      return <Slot ref={composedRefs}>{children}</Slot>;\n    }\n  );\n\n  CollectionSlot.displayName = COLLECTION_SLOT_NAME;\n\n  /* -----------------------------------------------------------------------------------------------\n   * CollectionItem\n   * ---------------------------------------------------------------------------------------------*/\n\n  const ITEM_SLOT_NAME = name + 'CollectionItemSlot';\n  const ITEM_DATA_ATTR = 'data-radix-collection-item';\n\n  type CollectionItemSlotProps = ItemData & {\n    children: React.ReactNode;\n    scope: any;\n  };\n\n  const CollectionItemSlot = React.forwardRef<ItemElement, CollectionItemSlotProps>(\n    (props, forwardedRef) => {\n      const { scope, children, ...itemData } = props;\n      const ref = React.useRef<ItemElement>(null);\n      const composedRefs = useComposedRefs(forwardedRef, ref);\n      const context = useCollectionContext(ITEM_SLOT_NAME, scope);\n\n      React.useEffect(() => {\n        context.itemMap.set(ref, { ref, ...(itemData as unknown as ItemData) });\n        return () => void context.itemMap.delete(ref);\n      });\n\n      return (\n        <Slot {...{ [ITEM_DATA_ATTR]: '' }} ref={composedRefs}>\n          {children}\n        </Slot>\n      );\n    }\n  );\n\n  CollectionItemSlot.displayName = ITEM_SLOT_NAME;\n\n  /* -----------------------------------------------------------------------------------------------\n   * useCollection\n   * ---------------------------------------------------------------------------------------------*/\n\n  function useCollection(scope: any) {\n    const context = useCollectionContext(name + 'CollectionConsumer', scope);\n\n    const getItems = React.useCallback(() => {\n      const collectionNode = context.collectionRef.current;\n      if (!collectionNode) return [];\n      const orderedNodes = Array.from(collectionNode.querySelectorAll(`[${ITEM_DATA_ATTR}]`));\n      const items = Array.from(context.itemMap.values());\n      const orderedItems = items.sort(\n        (a, b) => orderedNodes.indexOf(a.ref.current!) - orderedNodes.indexOf(b.ref.current!)\n      );\n      return orderedItems;\n    }, [context.collectionRef, context.itemMap]);\n\n    return getItems;\n  }\n\n  return [\n    { Provider: CollectionProvider, Slot: CollectionSlot, ItemSlot: CollectionItemSlot },\n    useCollection,\n    createCollectionScope,\n  ] as const;\n}\n\nexport { createCollection };\nexport type { CollectionProps };\n"]},"metadata":{},"sourceType":"module"}