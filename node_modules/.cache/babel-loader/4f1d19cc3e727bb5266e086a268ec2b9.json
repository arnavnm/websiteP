{"ast":null,"code":"import { __assign, __awaiter, __generator } from \"tslib\";\nimport { runPolling } from \"./poller\";\nimport { validateWaiterOptions } from \"./utils\";\nimport { waiterServiceDefaults, WaiterState } from \"./waiter\";\n\nvar abortTimeout = function (abortSignal) {\n  return __awaiter(void 0, void 0, void 0, function () {\n    return __generator(this, function (_a) {\n      return [2\n      /*return*/\n      , new Promise(function (resolve) {\n        abortSignal.onabort = function () {\n          return resolve({\n            state: WaiterState.ABORTED\n          });\n        };\n      })];\n    });\n  });\n};\n/**\n * Create a waiter promise that only resolves when:\n * 1. Abort controller is signaled\n * 2. Max wait time is reached\n * 3. `acceptorChecks` succeeds, or fails\n * Otherwise, it invokes `acceptorChecks` with exponential-backoff delay.\n *\n * @internal\n */\n\n\nexport var createWaiter = function (options, input, acceptorChecks) {\n  return __awaiter(void 0, void 0, void 0, function () {\n    var params, exitConditions;\n    return __generator(this, function (_a) {\n      params = __assign(__assign({}, waiterServiceDefaults), options);\n      validateWaiterOptions(params);\n      exitConditions = [runPolling(params, input, acceptorChecks)];\n\n      if (options.abortController) {\n        exitConditions.push(abortTimeout(options.abortController.signal));\n      }\n\n      return [2\n      /*return*/\n      , Promise.race(exitConditions)];\n    });\n  });\n};","map":{"version":3,"mappings":"AAAA,SAASA,QAAT,EAAmBC,SAAnB,EAA8BC,WAA9B,QAAiD,OAAjD;AACA,SAASC,UAAT,QAA2B,UAA3B;AACA,SAASC,qBAAT,QAAsC,SAAtC;AACA,SAASC,qBAAT,EAAgCC,WAAhC,QAAmD,UAAnD;;AACA,IAAIC,YAAY,GAAG,UAAUC,WAAV,EAAuB;EAAE,OAAOP,SAAS,CAAC,KAAK,CAAN,EAAS,KAAK,CAAd,EAAiB,KAAK,CAAtB,EAAyB,YAAY;IAC7F,OAAOC,WAAW,CAAC,IAAD,EAAO,UAAUO,EAAV,EAAc;MACnC,OAAO,CAAC;MAAE;MAAH,EAAe,IAAIC,OAAJ,CAAY,UAAUC,OAAV,EAAmB;QAC7CH,WAAW,CAACI,OAAZ,GAAsB,YAAY;UAAE,OAAOD,OAAO,CAAC;YAAEE,KAAK,EAAEP,WAAW,CAACQ;UAArB,CAAD,CAAd;QAAiD,CAArF;MACH,CAFiB,CAAf,CAAP;IAGH,CAJiB,CAAlB;EAKH,CAN2D,CAAhB;AAMvC,CANL;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,OAAO,IAAIC,YAAY,GAAG,UAAUC,OAAV,EAAmBC,KAAnB,EAA0BC,cAA1B,EAA0C;EAAE,OAAOjB,SAAS,CAAC,KAAK,CAAN,EAAS,KAAK,CAAd,EAAiB,KAAK,CAAtB,EAAyB,YAAY;IACvH,IAAIkB,MAAJ,EAAYC,cAAZ;IACA,OAAOlB,WAAW,CAAC,IAAD,EAAO,UAAUO,EAAV,EAAc;MACnCU,MAAM,GAAGnB,QAAQ,CAACA,QAAQ,CAAC,EAAD,EAAKK,qBAAL,CAAT,EAAsCW,OAAtC,CAAjB;MACAZ,qBAAqB,CAACe,MAAD,CAArB;MACAC,cAAc,GAAG,CAACjB,UAAU,CAACgB,MAAD,EAASF,KAAT,EAAgBC,cAAhB,CAAX,CAAjB;;MACA,IAAIF,OAAO,CAACK,eAAZ,EAA6B;QACzBD,cAAc,CAACE,IAAf,CAAoBf,YAAY,CAACS,OAAO,CAACK,eAAR,CAAwBE,MAAzB,CAAhC;MACH;;MACD,OAAO,CAAC;MAAE;MAAH,EAAeb,OAAO,CAACc,IAAR,CAAaJ,cAAb,CAAf,CAAP;IACH,CARiB,CAAlB;EASH,CAXqF,CAAhB;AAWjE,CAXE","names":["runPolling","validateWaiterOptions","waiterServiceDefaults","WaiterState","abortTimeout","abortSignal","Promise","resolve","onabort","state","ABORTED","createWaiter","options","input","acceptorChecks","params","exitConditions","abortController","push","signal","race"],"sources":["/Users/arnavmisra/Desktop/Portfolio-main/node_modules/@aws-sdk/util-waiter/src/createWaiter.ts"],"sourcesContent":["import { AbortSignal } from \"@aws-sdk/types\";\n\nimport { runPolling } from \"./poller\";\nimport { validateWaiterOptions } from \"./utils\";\nimport { WaiterOptions, WaiterResult, waiterServiceDefaults, WaiterState } from \"./waiter\";\n\nconst abortTimeout = async (abortSignal: AbortSignal): Promise<WaiterResult> => {\n  return new Promise((resolve) => {\n    abortSignal.onabort = () => resolve({ state: WaiterState.ABORTED });\n  });\n};\n\n/**\n * Create a waiter promise that only resolves when:\n * 1. Abort controller is signaled\n * 2. Max wait time is reached\n * 3. `acceptorChecks` succeeds, or fails\n * Otherwise, it invokes `acceptorChecks` with exponential-backoff delay.\n *\n * @internal\n */\nexport const createWaiter = async <Client, Input>(\n  options: WaiterOptions<Client>,\n  input: Input,\n  acceptorChecks: (client: Client, input: Input) => Promise<WaiterResult>\n): Promise<WaiterResult> => {\n  const params = {\n    ...waiterServiceDefaults,\n    ...options,\n  };\n  validateWaiterOptions(params);\n\n  const exitConditions = [runPolling<Client, Input>(params, input, acceptorChecks)];\n  if (options.abortController) {\n    exitConditions.push(abortTimeout(options.abortController.signal));\n  }\n  return Promise.race(exitConditions);\n};\n"]},"metadata":{},"sourceType":"module"}