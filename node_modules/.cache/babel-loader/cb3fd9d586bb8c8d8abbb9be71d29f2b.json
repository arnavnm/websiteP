{"ast":null,"code":"import { composeRefs as e } from \"@radix-ui/react-compose-refs\";\nimport * as t from \"react\";\nimport r from \"@babel/runtime/helpers/esm/extends\";\nexport const Slot = /*#__PURE__*/t.forwardRef((e, o) => {\n  const {\n    children: a,\n    ...s\n  } = e;\n  return t.Children.toArray(a).some(l) ? /*#__PURE__*/t.createElement(t.Fragment, null, t.Children.map(a, e => l(e) ? /*#__PURE__*/t.createElement(n, r({}, s, {\n    ref: o\n  }), e.props.children) : e)) : /*#__PURE__*/t.createElement(n, r({}, s, {\n    ref: o\n  }), a);\n});\nSlot.displayName = \"Slot\";\nconst n = /*#__PURE__*/t.forwardRef((r, n) => {\n  const {\n    children: l,\n    ...a\n  } = r;\n  /*#__PURE__*/\n\n  return t.isValidElement(l) ? /*#__PURE__*/t.cloneElement(l, { ...o(a, l.props),\n    ref: e(n, l.ref)\n  }) : t.Children.count(l) > 1 ? t.Children.only(null) : null;\n});\nn.displayName = \"SlotClone\";\nexport const Slottable = _ref => {\n  let {\n    children: e\n  } = _ref;\n  return /*#__PURE__*/t.createElement(t.Fragment, null, e);\n};\n\nfunction l(e) {\n  /*#__PURE__*/\n  return t.isValidElement(e) && e.type === Slottable;\n}\n\nfunction o(e, t) {\n  const r = { ...t\n  };\n\n  for (const n in t) {\n    const l = e[n],\n          o = t[n];\n    /^on[A-Z]/.test(n) ? r[n] = function () {\n      null == o || o(...arguments), null == l || l(...arguments);\n    } : \"style\" === n ? r[n] = { ...l,\n      ...o\n    } : \"className\" === n && (r[n] = [l, o].filter(Boolean).join(\" \"));\n  }\n\n  return { ...e,\n    ...r\n  };\n}\n\nexport const Root = Slot;","map":{"version":3,"mappings":"AAAA,SAAOA,WAAW,IAAIC,CAAtB,QAA4B,8BAA5B;AAA2D,OAAM,KAAIC,CAAV,MAAgB,OAAhB;AAAwB,OAAOC,CAAP,MAAa,oCAAb;AAAkD,OAAO,MAAMC,IAAI,GAAC,aAAaF,CAAC,CAACG,UAAF,CAAc,CAACJ,CAAD,EAAGK,CAAH,KAAO;EAAC,MAAK;IAACC,QAAQ,EAACC,CAAV;IAAY,GAAGC;EAAf,IAAkBR,CAAvB;EAAyB,OAAOC,CAAC,CAACQ,QAAF,CAAWC,OAAX,CAAmBH,CAAnB,EAAsBI,IAAtB,CAA2BC,CAA3B,IAA8B,aAAaX,CAAC,CAACY,aAAF,CAAgBZ,CAAC,CAACa,QAAlB,EAA2B,IAA3B,EAAgCb,CAAC,CAACQ,QAAF,CAAWM,GAAX,CAAeR,CAAf,EAAkBP,CAAC,IAAEY,CAAC,CAACZ,CAAD,CAAD,GAAK,aAAaC,CAAC,CAACY,aAAF,CAAgBG,CAAhB,EAAkBd,CAAC,CAAC,EAAD,EAAIM,CAAJ,EAAM;IAACS,GAAG,EAACZ;EAAL,CAAN,CAAnB,EAAkCL,CAAC,CAACkB,KAAF,CAAQZ,QAA1C,CAAlB,GAAsEN,CAA3F,CAAhC,CAA3C,GAA2K,aAAaC,CAAC,CAACY,aAAF,CAAgBG,CAAhB,EAAkBd,CAAC,CAAC,EAAD,EAAIM,CAAJ,EAAM;IAACS,GAAG,EAACZ;EAAL,CAAN,CAAnB,EAAkCE,CAAlC,CAA/L;AAAoO,CAAnR,CAAxB;AAA8SJ,IAAI,CAACgB,WAAL,GAAiB,MAAjB;AAAwB,MAAMH,CAAC,GAAC,aAAaf,CAAC,CAACG,UAAF,CAAc,CAACF,CAAD,EAAGc,CAAH,KAAO;EAAC,MAAK;IAACV,QAAQ,EAACM,CAAV;IAAY,GAAGL;EAAf,IAAkBL,CAAvB;EAAyB;;EAAa,OAAOD,CAAC,CAACmB,cAAF,CAAiBR,CAAjB,IAAoB,aAAaX,CAAC,CAACoB,YAAF,CAAeT,CAAf,EAAiB,EAAC,GAAGP,CAAC,CAACE,CAAD,EAAGK,CAAC,CAACM,KAAL,CAAL;IAAiBD,GAAG,EAACjB,CAAC,CAACgB,CAAD,EAAGJ,CAAC,CAACK,GAAL;EAAtB,CAAjB,CAAjC,GAAoFhB,CAAC,CAACQ,QAAF,CAAWa,KAAX,CAAiBV,CAAjB,IAAoB,CAApB,GAAsBX,CAAC,CAACQ,QAAF,CAAWc,IAAX,CAAgB,IAAhB,CAAtB,GAA4C,IAAvI;AAA4I,CAAxM,CAArB;AAAgOP,CAAC,CAACG,WAAF,GAAc,WAAd;AAA0B,OAAO,MAAMK,SAAS,GAAC;EAAA,IAAC;IAAClB,QAAQ,EAACN;EAAV,CAAD;EAAA,OAAgB,aAAaC,CAAC,CAACY,aAAF,CAAgBZ,CAAC,CAACa,QAAlB,EAA2B,IAA3B,EAAgCd,CAAhC,CAA7B;AAAA,CAAhB;;AAAgF,SAASY,CAAT,CAAWZ,CAAX,EAAa;EAAC;EAAa,OAAOC,CAAC,CAACmB,cAAF,CAAiBpB,CAAjB,KAAqBA,CAAC,CAACyB,IAAF,KAASD,SAArC;AAA+C;;AAAA,SAASnB,CAAT,CAAWL,CAAX,EAAaC,CAAb,EAAe;EAAC,MAAMC,CAAC,GAAC,EAAC,GAAGD;EAAJ,CAAR;;EAAe,KAAI,MAAMe,CAAV,IAAef,CAAf,EAAiB;IAAC,MAAMW,CAAC,GAACZ,CAAC,CAACgB,CAAD,CAAT;IAAA,MAAaX,CAAC,GAACJ,CAAC,CAACe,CAAD,CAAhB;IAAoB,WAAWU,IAAX,CAAgBV,CAAhB,IAAmBd,CAAC,CAACc,CAAD,CAAD,GAAK,YAAQ;MAAC,QAAMX,CAAN,IAASA,CAAC,CAAC,YAAD,CAAV,EAAiB,QAAMO,CAAN,IAASA,CAAC,CAAC,YAAD,CAA3B;IAAkC,CAAnE,GAAoE,YAAUI,CAAV,GAAYd,CAAC,CAACc,CAAD,CAAD,GAAK,EAAC,GAAGJ,CAAJ;MAAM,GAAGP;IAAT,CAAjB,GAA6B,gBAAcW,CAAd,KAAkBd,CAAC,CAACc,CAAD,CAAD,GAAK,CAACJ,CAAD,EAAGP,CAAH,EAAMsB,MAAN,CAAaC,OAAb,EAAsBC,IAAtB,CAA2B,GAA3B,CAAvB,CAAjG;EAAyJ;;EAAA,OAAM,EAAC,GAAG7B,CAAJ;IAAM,GAAGE;EAAT,CAAN;AAAkB;;AAAA,OAAO,MAAM4B,IAAI,GAAC3B,IAAX","names":["Slot","React","forwardRef","props","forwardedRef","children","slotProps","Children","toArray","some","isSlottable","_react","map","child","$d34e8c328cb3dd19ab7a2f6eafa6ad$var$SlotClone","_babelRuntimeHelpersEsmExtends","ref","displayName","SlotClone","isValidElement","cloneElement","mergeProps","composeRefs","count","only","Slottable","type","childProps","overrideProps","propName","slotPropValue","childPropValue","test","args","filter","Boolean","join","Root"],"sources":["/Users/arnavmisra/Desktop/Portfolio-main/node_modules/@radix-ui/react-slot/dist/packages/react/slot/src/Slot.tsx"],"sourcesContent":["import * as React from 'react';\nimport { composeRefs } from '@radix-ui/react-compose-refs';\n\n/* -------------------------------------------------------------------------------------------------\n * Slot\n * -----------------------------------------------------------------------------------------------*/\n\ninterface SlotProps extends React.HTMLAttributes<HTMLElement> {\n  children?: React.ReactNode;\n}\n\nconst Slot = React.forwardRef<HTMLElement, SlotProps>((props, forwardedRef) => {\n  const { children, ...slotProps } = props;\n\n  if (React.Children.toArray(children).some(isSlottable)) {\n    return (\n      <>\n        {React.Children.map(children, (child) => {\n          return isSlottable(child) ? (\n            <SlotClone {...slotProps} ref={forwardedRef}>\n              {child.props.children}\n            </SlotClone>\n          ) : (\n            child\n          );\n        })}\n      </>\n    );\n  }\n\n  return (\n    <SlotClone {...slotProps} ref={forwardedRef}>\n      {children}\n    </SlotClone>\n  );\n});\n\nSlot.displayName = 'Slot';\n\n/* -------------------------------------------------------------------------------------------------\n * SlotClone\n * -----------------------------------------------------------------------------------------------*/\n\ninterface SlotCloneProps {\n  children: React.ReactNode;\n}\n\nconst SlotClone = React.forwardRef<any, SlotCloneProps>((props, forwardedRef) => {\n  const { children, ...slotProps } = props;\n\n  if (React.isValidElement(children)) {\n    return React.cloneElement(children, {\n      ...mergeProps(slotProps, children.props),\n      ref: composeRefs(forwardedRef, (children as any).ref),\n    });\n  }\n\n  return React.Children.count(children) > 1 ? React.Children.only(null) : null;\n});\n\nSlotClone.displayName = 'SlotClone';\n\n/* -------------------------------------------------------------------------------------------------\n * Slottable\n * -----------------------------------------------------------------------------------------------*/\n\nconst Slottable = ({ children }: { children: React.ReactNode }) => {\n  return <>{children}</>;\n};\n\n/* ---------------------------------------------------------------------------------------------- */\n\ntype AnyProps = Record<string, any>;\n\nfunction isSlottable(child: React.ReactNode): child is React.ReactElement {\n  return React.isValidElement(child) && child.type === Slottable;\n}\n\nfunction mergeProps(slotProps: AnyProps, childProps: AnyProps) {\n  // all child props should override\n  const overrideProps = { ...childProps };\n\n  for (const propName in childProps) {\n    const slotPropValue = slotProps[propName];\n    const childPropValue = childProps[propName];\n\n    const isHandler = /^on[A-Z]/.test(propName);\n    // if it's a handler, modify the override by composing the base handler\n    if (isHandler) {\n      overrideProps[propName] = (...args: unknown[]) => {\n        childPropValue?.(...args);\n        slotPropValue?.(...args);\n      };\n    }\n    // if it's `style`, we merge them\n    else if (propName === 'style') {\n      overrideProps[propName] = { ...slotPropValue, ...childPropValue };\n    } else if (propName === 'className') {\n      overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(' ');\n    }\n  }\n\n  return { ...slotProps, ...overrideProps };\n}\n\nconst Root = Slot;\n\nexport {\n  Slot,\n  Slottable,\n  //\n  Root,\n};\nexport type { SlotProps };\n"]},"metadata":{},"sourceType":"module"}