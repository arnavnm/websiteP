{"ast":null,"code":"import { colorMix, colorToRgb, getStyleFromHsl, getStyleFromRgb } from \"./ColorUtils\";\nimport { getDistance, getDistances } from \"./NumberUtils\";\n\nfunction drawLine(context, begin, end) {\n  context.beginPath();\n  context.moveTo(begin.x, begin.y);\n  context.lineTo(end.x, end.y);\n  context.closePath();\n}\n\nfunction drawTriangle(context, p1, p2, p3) {\n  context.beginPath();\n  context.moveTo(p1.x, p1.y);\n  context.lineTo(p2.x, p2.y);\n  context.lineTo(p3.x, p3.y);\n  context.closePath();\n}\n\nexport function paintBase(context, dimension, baseColor) {\n  context.save();\n  context.fillStyle = baseColor !== null && baseColor !== void 0 ? baseColor : \"rgba(0,0,0,0)\";\n  context.fillRect(0, 0, dimension.width, dimension.height);\n  context.restore();\n}\nexport function clear(context, dimension) {\n  context.clearRect(0, 0, dimension.width, dimension.height);\n}\nexport function drawLinkLine(context, width, begin, end, maxDistance, canvasSize, warp, backgroundMask, composite, colorLine, opacity, shadow) {\n  let drawn = false;\n\n  if (getDistance(begin, end) <= maxDistance) {\n    drawLine(context, begin, end);\n    drawn = true;\n  } else if (warp) {\n    let pi1;\n    let pi2;\n    const endNE = {\n      x: end.x - canvasSize.width,\n      y: end.y\n    };\n    const d1 = getDistances(begin, endNE);\n\n    if (d1.distance <= maxDistance) {\n      const yi = begin.y - d1.dy / d1.dx * begin.x;\n      pi1 = {\n        x: 0,\n        y: yi\n      };\n      pi2 = {\n        x: canvasSize.width,\n        y: yi\n      };\n    } else {\n      const endSW = {\n        x: end.x,\n        y: end.y - canvasSize.height\n      };\n      const d2 = getDistances(begin, endSW);\n\n      if (d2.distance <= maxDistance) {\n        const yi = begin.y - d2.dy / d2.dx * begin.x;\n        const xi = -yi / (d2.dy / d2.dx);\n        pi1 = {\n          x: xi,\n          y: 0\n        };\n        pi2 = {\n          x: xi,\n          y: canvasSize.height\n        };\n      } else {\n        const endSE = {\n          x: end.x - canvasSize.width,\n          y: end.y - canvasSize.height\n        };\n        const d3 = getDistances(begin, endSE);\n\n        if (d3.distance <= maxDistance) {\n          const yi = begin.y - d3.dy / d3.dx * begin.x;\n          const xi = -yi / (d3.dy / d3.dx);\n          pi1 = {\n            x: xi,\n            y: yi\n          };\n          pi2 = {\n            x: pi1.x + canvasSize.width,\n            y: pi1.y + canvasSize.height\n          };\n        }\n      }\n    }\n\n    if (pi1 && pi2) {\n      drawLine(context, begin, pi1);\n      drawLine(context, end, pi2);\n      drawn = true;\n    }\n  }\n\n  if (!drawn) {\n    return;\n  }\n\n  context.lineWidth = width;\n\n  if (backgroundMask) {\n    context.globalCompositeOperation = composite;\n  }\n\n  context.strokeStyle = getStyleFromRgb(colorLine, opacity);\n\n  if (shadow.enable) {\n    const shadowColor = colorToRgb(shadow.color);\n\n    if (shadowColor) {\n      context.shadowBlur = shadow.blur;\n      context.shadowColor = getStyleFromRgb(shadowColor);\n    }\n  }\n\n  context.stroke();\n}\nexport function drawLinkTriangle(context, pos1, pos2, pos3, backgroundMask, composite, colorTriangle, opacityTriangle) {\n  drawTriangle(context, pos1, pos2, pos3);\n\n  if (backgroundMask) {\n    context.globalCompositeOperation = composite;\n  }\n\n  context.fillStyle = getStyleFromRgb(colorTriangle, opacityTriangle);\n  context.fill();\n}\nexport function drawConnectLine(context, width, lineStyle, begin, end) {\n  context.save();\n  drawLine(context, begin, end);\n  context.lineWidth = width;\n  context.strokeStyle = lineStyle;\n  context.stroke();\n  context.restore();\n}\nexport function gradient(context, p1, p2, opacity) {\n  const gradStop = Math.floor(p2.getRadius() / p1.getRadius());\n  const color1 = p1.getFillColor();\n  const color2 = p2.getFillColor();\n\n  if (!color1 || !color2) {\n    return;\n  }\n\n  const sourcePos = p1.getPosition();\n  const destPos = p2.getPosition();\n  const midRgb = colorMix(color1, color2, p1.getRadius(), p2.getRadius());\n  const grad = context.createLinearGradient(sourcePos.x, sourcePos.y, destPos.x, destPos.y);\n  grad.addColorStop(0, getStyleFromHsl(color1, opacity));\n  grad.addColorStop(gradStop > 1 ? 1 : gradStop, getStyleFromRgb(midRgb, opacity));\n  grad.addColorStop(1, getStyleFromHsl(color2, opacity));\n  return grad;\n}\nexport function drawGrabLine(context, width, begin, end, colorLine, opacity) {\n  context.save();\n  drawLine(context, begin, end);\n  context.strokeStyle = getStyleFromRgb(colorLine, opacity);\n  context.lineWidth = width;\n  context.stroke();\n  context.restore();\n}\nexport function drawParticle(container, context, particle, delta, fillColorValue, strokeColorValue, backgroundMask, composite, radius, opacity, shadow, gradient) {\n  var _a, _b, _c, _d, _e, _f;\n\n  const pos = particle.getPosition();\n  const tiltOptions = particle.options.tilt;\n  const rollOptions = particle.options.roll;\n  context.save();\n\n  if (tiltOptions.enable || rollOptions.enable) {\n    const roll = rollOptions.enable && particle.roll;\n    const tilt = tiltOptions.enable && particle.tilt;\n    const rollHorizontal = roll && (rollOptions.mode === \"horizontal\" || rollOptions.mode === \"both\");\n    const rollVertical = roll && (rollOptions.mode === \"vertical\" || rollOptions.mode === \"both\");\n    context.setTransform(rollHorizontal ? Math.cos(particle.roll.angle) : 1, tilt ? Math.cos(particle.tilt.value) * particle.tilt.cosDirection : 0, tilt ? Math.sin(particle.tilt.value) * particle.tilt.sinDirection : 0, rollVertical ? Math.sin(particle.roll.angle) : 1, pos.x, pos.y);\n  } else {\n    context.translate(pos.x, pos.y);\n  }\n\n  context.beginPath();\n  const angle = ((_b = (_a = particle.rotate) === null || _a === void 0 ? void 0 : _a.value) !== null && _b !== void 0 ? _b : 0) + (particle.options.rotate.path ? particle.velocity.angle : 0);\n\n  if (angle !== 0) {\n    context.rotate(angle);\n  }\n\n  if (backgroundMask) {\n    context.globalCompositeOperation = composite;\n  }\n\n  const shadowColor = particle.shadowColor;\n\n  if (shadow.enable && shadowColor) {\n    context.shadowBlur = shadow.blur;\n    context.shadowColor = getStyleFromRgb(shadowColor);\n    context.shadowOffsetX = shadow.offset.x;\n    context.shadowOffsetY = shadow.offset.y;\n  }\n\n  if (gradient) {\n    const gradientAngle = gradient.angle.value;\n    const fillGradient = gradient.type === \"radial\" ? context.createRadialGradient(0, 0, 0, 0, 0, radius) : context.createLinearGradient(Math.cos(gradientAngle) * -radius, Math.sin(gradientAngle) * -radius, Math.cos(gradientAngle) * radius, Math.sin(gradientAngle) * radius);\n\n    for (const color of gradient.colors) {\n      fillGradient.addColorStop(color.stop, getStyleFromHsl({\n        h: color.value.h.value,\n        s: color.value.s.value,\n        l: color.value.l.value\n      }, (_d = (_c = color.opacity) === null || _c === void 0 ? void 0 : _c.value) !== null && _d !== void 0 ? _d : opacity));\n    }\n\n    context.fillStyle = fillGradient;\n  } else {\n    if (fillColorValue) {\n      context.fillStyle = fillColorValue;\n    }\n  }\n\n  const stroke = particle.stroke;\n  context.lineWidth = (_e = particle.strokeWidth) !== null && _e !== void 0 ? _e : 0;\n\n  if (strokeColorValue) {\n    context.strokeStyle = strokeColorValue;\n  }\n\n  drawShape(container, context, particle, radius, opacity, delta);\n\n  if (((_f = stroke === null || stroke === void 0 ? void 0 : stroke.width) !== null && _f !== void 0 ? _f : 0) > 0) {\n    context.stroke();\n  }\n\n  if (particle.close) {\n    context.closePath();\n  }\n\n  if (particle.fill) {\n    context.fill();\n  }\n\n  context.restore();\n  context.save();\n\n  if (tiltOptions.enable && particle.tilt) {\n    context.setTransform(1, Math.cos(particle.tilt.value) * particle.tilt.cosDirection, Math.sin(particle.tilt.value) * particle.tilt.sinDirection, 1, pos.x, pos.y);\n  } else {\n    context.translate(pos.x, pos.y);\n  }\n\n  if (angle !== 0) {\n    context.rotate(angle);\n  }\n\n  if (backgroundMask) {\n    context.globalCompositeOperation = composite;\n  }\n\n  drawShapeAfterEffect(container, context, particle, radius, opacity, delta);\n  context.restore();\n}\nexport function drawShape(container, context, particle, radius, opacity, delta) {\n  if (!particle.shape) {\n    return;\n  }\n\n  const drawer = container.drawers.get(particle.shape);\n\n  if (!drawer) {\n    return;\n  }\n\n  drawer.draw(context, particle, radius, opacity, delta, container.retina.pixelRatio);\n}\nexport function drawShapeAfterEffect(container, context, particle, radius, opacity, delta) {\n  if (!particle.shape) {\n    return;\n  }\n\n  const drawer = container.drawers.get(particle.shape);\n\n  if (!(drawer === null || drawer === void 0 ? void 0 : drawer.afterEffect)) {\n    return;\n  }\n\n  drawer.afterEffect(context, particle, radius, opacity, delta, container.retina.pixelRatio);\n}\nexport function drawPlugin(context, plugin, delta) {\n  if (!plugin.draw) {\n    return;\n  }\n\n  context.save();\n  plugin.draw(context, delta);\n  context.restore();\n}\nexport function drawParticlePlugin(context, plugin, particle, delta) {\n  if (plugin.drawParticle !== undefined) {\n    context.save();\n    plugin.drawParticle(context, particle, delta);\n    context.restore();\n  }\n}\nexport function drawEllipse(context, particle, fillColorValue, radius, opacity, width, rotation, start, end) {\n  const pos = particle.getPosition();\n\n  if (fillColorValue) {\n    context.strokeStyle = getStyleFromHsl(fillColorValue, opacity);\n  }\n\n  if (width === 0) {\n    return;\n  }\n\n  context.lineWidth = width;\n  const rotationRadian = rotation * Math.PI / 180;\n  context.beginPath();\n  context.ellipse(pos.x, pos.y, radius / 2, radius * 2, rotationRadian, start, end);\n  context.stroke();\n}\nexport function alterHsl(color, type, value) {\n  return {\n    h: color.h,\n    s: color.s,\n    l: color.l + (type === \"darken\" ? -1 : 1) * value\n  };\n}","map":{"version":3,"names":["colorMix","colorToRgb","getStyleFromHsl","getStyleFromRgb","getDistance","getDistances","drawLine","context","begin","end","beginPath","moveTo","x","y","lineTo","closePath","drawTriangle","p1","p2","p3","paintBase","dimension","baseColor","save","fillStyle","fillRect","width","height","restore","clear","clearRect","drawLinkLine","maxDistance","canvasSize","warp","backgroundMask","composite","colorLine","opacity","shadow","drawn","pi1","pi2","endNE","d1","distance","yi","dy","dx","endSW","d2","xi","endSE","d3","lineWidth","globalCompositeOperation","strokeStyle","enable","shadowColor","color","shadowBlur","blur","stroke","drawLinkTriangle","pos1","pos2","pos3","colorTriangle","opacityTriangle","fill","drawConnectLine","lineStyle","gradient","gradStop","Math","floor","getRadius","color1","getFillColor","color2","sourcePos","getPosition","destPos","midRgb","grad","createLinearGradient","addColorStop","drawGrabLine","drawParticle","container","particle","delta","fillColorValue","strokeColorValue","radius","_a","_b","_c","_d","_e","_f","pos","tiltOptions","options","tilt","rollOptions","roll","rollHorizontal","mode","rollVertical","setTransform","cos","angle","value","cosDirection","sin","sinDirection","translate","rotate","path","velocity","shadowOffsetX","offset","shadowOffsetY","gradientAngle","fillGradient","type","createRadialGradient","colors","stop","h","s","l","strokeWidth","drawShape","close","drawShapeAfterEffect","shape","drawer","drawers","get","draw","retina","pixelRatio","afterEffect","drawPlugin","plugin","drawParticlePlugin","undefined","drawEllipse","rotation","start","rotationRadian","PI","ellipse","alterHsl"],"sources":["/Users/arnavmisra/Desktop/Portfolio-main/Portfolio/node_modules/tsparticles/esm/Utils/CanvasUtils.js"],"sourcesContent":["import { colorMix, colorToRgb, getStyleFromHsl, getStyleFromRgb } from \"./ColorUtils\";\nimport { getDistance, getDistances } from \"./NumberUtils\";\nfunction drawLine(context, begin, end) {\n    context.beginPath();\n    context.moveTo(begin.x, begin.y);\n    context.lineTo(end.x, end.y);\n    context.closePath();\n}\nfunction drawTriangle(context, p1, p2, p3) {\n    context.beginPath();\n    context.moveTo(p1.x, p1.y);\n    context.lineTo(p2.x, p2.y);\n    context.lineTo(p3.x, p3.y);\n    context.closePath();\n}\nexport function paintBase(context, dimension, baseColor) {\n    context.save();\n    context.fillStyle = baseColor !== null && baseColor !== void 0 ? baseColor : \"rgba(0,0,0,0)\";\n    context.fillRect(0, 0, dimension.width, dimension.height);\n    context.restore();\n}\nexport function clear(context, dimension) {\n    context.clearRect(0, 0, dimension.width, dimension.height);\n}\nexport function drawLinkLine(context, width, begin, end, maxDistance, canvasSize, warp, backgroundMask, composite, colorLine, opacity, shadow) {\n    let drawn = false;\n    if (getDistance(begin, end) <= maxDistance) {\n        drawLine(context, begin, end);\n        drawn = true;\n    }\n    else if (warp) {\n        let pi1;\n        let pi2;\n        const endNE = {\n            x: end.x - canvasSize.width,\n            y: end.y,\n        };\n        const d1 = getDistances(begin, endNE);\n        if (d1.distance <= maxDistance) {\n            const yi = begin.y - (d1.dy / d1.dx) * begin.x;\n            pi1 = { x: 0, y: yi };\n            pi2 = { x: canvasSize.width, y: yi };\n        }\n        else {\n            const endSW = {\n                x: end.x,\n                y: end.y - canvasSize.height,\n            };\n            const d2 = getDistances(begin, endSW);\n            if (d2.distance <= maxDistance) {\n                const yi = begin.y - (d2.dy / d2.dx) * begin.x;\n                const xi = -yi / (d2.dy / d2.dx);\n                pi1 = { x: xi, y: 0 };\n                pi2 = { x: xi, y: canvasSize.height };\n            }\n            else {\n                const endSE = {\n                    x: end.x - canvasSize.width,\n                    y: end.y - canvasSize.height,\n                };\n                const d3 = getDistances(begin, endSE);\n                if (d3.distance <= maxDistance) {\n                    const yi = begin.y - (d3.dy / d3.dx) * begin.x;\n                    const xi = -yi / (d3.dy / d3.dx);\n                    pi1 = { x: xi, y: yi };\n                    pi2 = { x: pi1.x + canvasSize.width, y: pi1.y + canvasSize.height };\n                }\n            }\n        }\n        if (pi1 && pi2) {\n            drawLine(context, begin, pi1);\n            drawLine(context, end, pi2);\n            drawn = true;\n        }\n    }\n    if (!drawn) {\n        return;\n    }\n    context.lineWidth = width;\n    if (backgroundMask) {\n        context.globalCompositeOperation = composite;\n    }\n    context.strokeStyle = getStyleFromRgb(colorLine, opacity);\n    if (shadow.enable) {\n        const shadowColor = colorToRgb(shadow.color);\n        if (shadowColor) {\n            context.shadowBlur = shadow.blur;\n            context.shadowColor = getStyleFromRgb(shadowColor);\n        }\n    }\n    context.stroke();\n}\nexport function drawLinkTriangle(context, pos1, pos2, pos3, backgroundMask, composite, colorTriangle, opacityTriangle) {\n    drawTriangle(context, pos1, pos2, pos3);\n    if (backgroundMask) {\n        context.globalCompositeOperation = composite;\n    }\n    context.fillStyle = getStyleFromRgb(colorTriangle, opacityTriangle);\n    context.fill();\n}\nexport function drawConnectLine(context, width, lineStyle, begin, end) {\n    context.save();\n    drawLine(context, begin, end);\n    context.lineWidth = width;\n    context.strokeStyle = lineStyle;\n    context.stroke();\n    context.restore();\n}\nexport function gradient(context, p1, p2, opacity) {\n    const gradStop = Math.floor(p2.getRadius() / p1.getRadius());\n    const color1 = p1.getFillColor();\n    const color2 = p2.getFillColor();\n    if (!color1 || !color2) {\n        return;\n    }\n    const sourcePos = p1.getPosition();\n    const destPos = p2.getPosition();\n    const midRgb = colorMix(color1, color2, p1.getRadius(), p2.getRadius());\n    const grad = context.createLinearGradient(sourcePos.x, sourcePos.y, destPos.x, destPos.y);\n    grad.addColorStop(0, getStyleFromHsl(color1, opacity));\n    grad.addColorStop(gradStop > 1 ? 1 : gradStop, getStyleFromRgb(midRgb, opacity));\n    grad.addColorStop(1, getStyleFromHsl(color2, opacity));\n    return grad;\n}\nexport function drawGrabLine(context, width, begin, end, colorLine, opacity) {\n    context.save();\n    drawLine(context, begin, end);\n    context.strokeStyle = getStyleFromRgb(colorLine, opacity);\n    context.lineWidth = width;\n    context.stroke();\n    context.restore();\n}\nexport function drawParticle(container, context, particle, delta, fillColorValue, strokeColorValue, backgroundMask, composite, radius, opacity, shadow, gradient) {\n    var _a, _b, _c, _d, _e, _f;\n    const pos = particle.getPosition();\n    const tiltOptions = particle.options.tilt;\n    const rollOptions = particle.options.roll;\n    context.save();\n    if (tiltOptions.enable || rollOptions.enable) {\n        const roll = rollOptions.enable && particle.roll;\n        const tilt = tiltOptions.enable && particle.tilt;\n        const rollHorizontal = roll && (rollOptions.mode === \"horizontal\" || rollOptions.mode === \"both\");\n        const rollVertical = roll && (rollOptions.mode === \"vertical\" || rollOptions.mode === \"both\");\n        context.setTransform(rollHorizontal ? Math.cos(particle.roll.angle) : 1, tilt ? Math.cos(particle.tilt.value) * particle.tilt.cosDirection : 0, tilt ? Math.sin(particle.tilt.value) * particle.tilt.sinDirection : 0, rollVertical ? Math.sin(particle.roll.angle) : 1, pos.x, pos.y);\n    }\n    else {\n        context.translate(pos.x, pos.y);\n    }\n    context.beginPath();\n    const angle = ((_b = (_a = particle.rotate) === null || _a === void 0 ? void 0 : _a.value) !== null && _b !== void 0 ? _b : 0) + (particle.options.rotate.path ? particle.velocity.angle : 0);\n    if (angle !== 0) {\n        context.rotate(angle);\n    }\n    if (backgroundMask) {\n        context.globalCompositeOperation = composite;\n    }\n    const shadowColor = particle.shadowColor;\n    if (shadow.enable && shadowColor) {\n        context.shadowBlur = shadow.blur;\n        context.shadowColor = getStyleFromRgb(shadowColor);\n        context.shadowOffsetX = shadow.offset.x;\n        context.shadowOffsetY = shadow.offset.y;\n    }\n    if (gradient) {\n        const gradientAngle = gradient.angle.value;\n        const fillGradient = gradient.type === \"radial\"\n            ? context.createRadialGradient(0, 0, 0, 0, 0, radius)\n            : context.createLinearGradient(Math.cos(gradientAngle) * -radius, Math.sin(gradientAngle) * -radius, Math.cos(gradientAngle) * radius, Math.sin(gradientAngle) * radius);\n        for (const color of gradient.colors) {\n            fillGradient.addColorStop(color.stop, getStyleFromHsl({\n                h: color.value.h.value,\n                s: color.value.s.value,\n                l: color.value.l.value,\n            }, (_d = (_c = color.opacity) === null || _c === void 0 ? void 0 : _c.value) !== null && _d !== void 0 ? _d : opacity));\n        }\n        context.fillStyle = fillGradient;\n    }\n    else {\n        if (fillColorValue) {\n            context.fillStyle = fillColorValue;\n        }\n    }\n    const stroke = particle.stroke;\n    context.lineWidth = (_e = particle.strokeWidth) !== null && _e !== void 0 ? _e : 0;\n    if (strokeColorValue) {\n        context.strokeStyle = strokeColorValue;\n    }\n    drawShape(container, context, particle, radius, opacity, delta);\n    if (((_f = stroke === null || stroke === void 0 ? void 0 : stroke.width) !== null && _f !== void 0 ? _f : 0) > 0) {\n        context.stroke();\n    }\n    if (particle.close) {\n        context.closePath();\n    }\n    if (particle.fill) {\n        context.fill();\n    }\n    context.restore();\n    context.save();\n    if (tiltOptions.enable && particle.tilt) {\n        context.setTransform(1, Math.cos(particle.tilt.value) * particle.tilt.cosDirection, Math.sin(particle.tilt.value) * particle.tilt.sinDirection, 1, pos.x, pos.y);\n    }\n    else {\n        context.translate(pos.x, pos.y);\n    }\n    if (angle !== 0) {\n        context.rotate(angle);\n    }\n    if (backgroundMask) {\n        context.globalCompositeOperation = composite;\n    }\n    drawShapeAfterEffect(container, context, particle, radius, opacity, delta);\n    context.restore();\n}\nexport function drawShape(container, context, particle, radius, opacity, delta) {\n    if (!particle.shape) {\n        return;\n    }\n    const drawer = container.drawers.get(particle.shape);\n    if (!drawer) {\n        return;\n    }\n    drawer.draw(context, particle, radius, opacity, delta, container.retina.pixelRatio);\n}\nexport function drawShapeAfterEffect(container, context, particle, radius, opacity, delta) {\n    if (!particle.shape) {\n        return;\n    }\n    const drawer = container.drawers.get(particle.shape);\n    if (!(drawer === null || drawer === void 0 ? void 0 : drawer.afterEffect)) {\n        return;\n    }\n    drawer.afterEffect(context, particle, radius, opacity, delta, container.retina.pixelRatio);\n}\nexport function drawPlugin(context, plugin, delta) {\n    if (!plugin.draw) {\n        return;\n    }\n    context.save();\n    plugin.draw(context, delta);\n    context.restore();\n}\nexport function drawParticlePlugin(context, plugin, particle, delta) {\n    if (plugin.drawParticle !== undefined) {\n        context.save();\n        plugin.drawParticle(context, particle, delta);\n        context.restore();\n    }\n}\nexport function drawEllipse(context, particle, fillColorValue, radius, opacity, width, rotation, start, end) {\n    const pos = particle.getPosition();\n    if (fillColorValue) {\n        context.strokeStyle = getStyleFromHsl(fillColorValue, opacity);\n    }\n    if (width === 0) {\n        return;\n    }\n    context.lineWidth = width;\n    const rotationRadian = (rotation * Math.PI) / 180;\n    context.beginPath();\n    context.ellipse(pos.x, pos.y, radius / 2, radius * 2, rotationRadian, start, end);\n    context.stroke();\n}\nexport function alterHsl(color, type, value) {\n    return {\n        h: color.h,\n        s: color.s,\n        l: color.l + (type === \"darken\" ? -1 : 1) * value,\n    };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}