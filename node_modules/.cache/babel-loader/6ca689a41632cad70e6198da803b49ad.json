{"ast":null,"code":"import _slicedToArray from \"/Users/arnavmisra/Desktop/Portfolio-main/Portfolio/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport { useLayoutEffect as e } from \"@radix-ui/react-use-layout-effect\";\nimport { useComposedRefs as n } from \"@radix-ui/react-compose-refs\";\nimport * as t from \"react\";\nexport var Presence = function Presence(u) {\n  var o = u.present,\n      i = u.children,\n      s = function (n) {\n    var _t$useState = t.useState(),\n        _t$useState2 = _slicedToArray(_t$useState, 2),\n        u = _t$useState2[0],\n        o = _t$useState2[1],\n        i = t.useRef({}),\n        s = t.useRef(n),\n        c = t.useRef(\"none\"),\n        a = n ? \"mounted\" : \"unmounted\",\n        _ref = function (e, n) {\n      return t.useReducer(function (e, t) {\n        var r = n[e][t];\n        return null != r ? r : e;\n      }, e);\n    }(a, {\n      mounted: {\n        UNMOUNT: \"unmounted\",\n        ANIMATION_OUT: \"unmountSuspended\"\n      },\n      unmountSuspended: {\n        MOUNT: \"mounted\",\n        ANIMATION_END: \"unmounted\"\n      },\n      unmounted: {\n        MOUNT: \"mounted\"\n      }\n    }),\n        _ref2 = _slicedToArray(_ref, 2),\n        d = _ref2[0],\n        m = _ref2[1];\n\n    return t.useEffect(function () {\n      var e = r(i.current);\n      c.current = \"mounted\" === d ? e : \"none\";\n    }, [d]), e(function () {\n      var e = i.current,\n          t = s.current;\n\n      if (t !== n) {\n        var _u = c.current,\n            _o = r(e);\n\n        if (n) m(\"MOUNT\");else if (\"none\" === _o || \"none\" === (null == e ? void 0 : e.display)) m(\"UNMOUNT\");else {\n          var _e = _u !== _o;\n\n          m(t && _e ? \"ANIMATION_OUT\" : \"UNMOUNT\");\n        }\n        s.current = n;\n      }\n    }, [n, m]), e(function () {\n      if (u) {\n        var _e2 = function _e2(e) {\n          var n = r(i.current).includes(e.animationName);\n          e.target === u && n && m(\"ANIMATION_END\");\n        },\n            _n = function _n(e) {\n          e.target === u && (c.current = r(i.current));\n        };\n\n        return u.addEventListener(\"animationstart\", _n), u.addEventListener(\"animationcancel\", _e2), u.addEventListener(\"animationend\", _e2), function () {\n          u.removeEventListener(\"animationstart\", _n), u.removeEventListener(\"animationcancel\", _e2), u.removeEventListener(\"animationend\", _e2);\n        };\n      }\n\n      m(\"ANIMATION_END\");\n    }, [u, m]), {\n      isPresent: [\"mounted\", \"unmountSuspended\"].includes(d),\n      ref: t.useCallback(function (e) {\n        e && (i.current = getComputedStyle(e)), o(e);\n      }, [])\n    };\n  }(o),\n      c = \"function\" == typeof i ? i({\n    present: s.isPresent\n  }) : t.Children.only(i),\n      a = n(s.ref, c.ref);\n\n  return \"function\" == typeof i || s.isPresent ? /*#__PURE__*/t.cloneElement(c, {\n    ref: a\n  }) : null;\n};\n\nfunction r(e) {\n  return (null == e ? void 0 : e.animationName) || \"none\";\n}\n\nPresence.displayName = \"Presence\";","map":{"version":3,"mappings":"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","names":["Presence","props","present","children","presence","React","useState","node","setNode","stylesRef","useRef","prevPresentRef","prevAnimationNameRef","initialState","machine","useReducer","state","event","nextState","$d88c0747af12355025ed3195fb48c68a$export$useStateMachine","mounted","UNMOUNT","ANIMATION_OUT","unmountSuspended","MOUNT","ANIMATION_END","unmounted","send","useEffect","currentAnimationName","getAnimationName","current","useLayoutEffect","styles","wasPresent","prevAnimationName","display","isAnimating","handleAnimationEnd","isCurrentAnimation","includes","animationName","target","handleAnimationStart","addEventListener","removeEventListener","isPresent","ref","useCallback","getComputedStyle","usePresence","child","Children","only","useComposedRefs","cloneElement","displayName"],"sources":["/Users/arnavmisra/Desktop/Portfolio-main/Portfolio/node_modules/@radix-ui/react-presence/dist/packages/react/presence/src/Presence.tsx","/Users/arnavmisra/Desktop/Portfolio-main/Portfolio/node_modules/@radix-ui/react-presence/dist/packages/react/presence/src/useStateMachine.tsx"],"sourcesContent":["import * as React from 'react';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { useLayoutEffect } from '@radix-ui/react-use-layout-effect';\nimport { useStateMachine } from './useStateMachine';\n\ninterface PresenceProps {\n  present: boolean;\n  children: React.ReactElement | ((props: { present: boolean }) => React.ReactElement);\n}\n\nconst Presence: React.FC<PresenceProps> = (props) => {\n  const { present, children } = props;\n  const presence = usePresence(present);\n\n  const child = (\n    typeof children === 'function'\n      ? children({ present: presence.isPresent })\n      : React.Children.only(children)\n  ) as React.ReactElement;\n\n  const ref = useComposedRefs(presence.ref, (child as any).ref);\n  const forceMount = typeof children === 'function';\n  return forceMount || presence.isPresent ? React.cloneElement(child, { ref }) : null;\n};\n\nPresence.displayName = 'Presence';\n\n/* -------------------------------------------------------------------------------------------------\n * usePresence\n * -----------------------------------------------------------------------------------------------*/\n\nfunction usePresence(present: boolean) {\n  const [node, setNode] = React.useState<HTMLElement>();\n  const stylesRef = React.useRef<CSSStyleDeclaration>({} as any);\n  const prevPresentRef = React.useRef(present);\n  const prevAnimationNameRef = React.useRef<string>('none');\n  const initialState = present ? 'mounted' : 'unmounted';\n  const [state, send] = useStateMachine(initialState, {\n    mounted: {\n      UNMOUNT: 'unmounted',\n      ANIMATION_OUT: 'unmountSuspended',\n    },\n    unmountSuspended: {\n      MOUNT: 'mounted',\n      ANIMATION_END: 'unmounted',\n    },\n    unmounted: {\n      MOUNT: 'mounted',\n    },\n  });\n\n  React.useEffect(() => {\n    const currentAnimationName = getAnimationName(stylesRef.current);\n    prevAnimationNameRef.current = state === 'mounted' ? currentAnimationName : 'none';\n  }, [state]);\n\n  useLayoutEffect(() => {\n    const styles = stylesRef.current;\n    const wasPresent = prevPresentRef.current;\n    const hasPresentChanged = wasPresent !== present;\n\n    if (hasPresentChanged) {\n      const prevAnimationName = prevAnimationNameRef.current;\n      const currentAnimationName = getAnimationName(styles);\n\n      if (present) {\n        send('MOUNT');\n      } else if (currentAnimationName === 'none' || styles?.display === 'none') {\n        // If there is no exit animation or the element is hidden, animations won't run\n        // so we unmount instantly\n        send('UNMOUNT');\n      } else {\n        /**\n         * When `present` changes to `false`, we check changes to animation-name to\n         * determine whether an animation has started. We chose this approach (reading\n         * computed styles) because there is no `animationrun` event and `animationstart`\n         * fires after `animation-delay` has expired which would be too late.\n         */\n        const isAnimating = prevAnimationName !== currentAnimationName;\n\n        if (wasPresent && isAnimating) {\n          send('ANIMATION_OUT');\n        } else {\n          send('UNMOUNT');\n        }\n      }\n\n      prevPresentRef.current = present;\n    }\n  }, [present, send]);\n\n  useLayoutEffect(() => {\n    if (node) {\n      /**\n       * Triggering an ANIMATION_OUT during an ANIMATION_IN will fire an `animationcancel`\n       * event for ANIMATION_IN after we have entered `unmountSuspended` state. So, we\n       * make sure we only trigger ANIMATION_END for the currently active animation.\n       */\n      const handleAnimationEnd = (event: AnimationEvent) => {\n        const currentAnimationName = getAnimationName(stylesRef.current);\n        const isCurrentAnimation = currentAnimationName.includes(event.animationName);\n        if (event.target === node && isCurrentAnimation) {\n          send('ANIMATION_END');\n        }\n      };\n      const handleAnimationStart = (event: AnimationEvent) => {\n        if (event.target === node) {\n          // if animation occurred, store its name as the previous animation.\n          prevAnimationNameRef.current = getAnimationName(stylesRef.current);\n        }\n      };\n      node.addEventListener('animationstart', handleAnimationStart);\n      node.addEventListener('animationcancel', handleAnimationEnd);\n      node.addEventListener('animationend', handleAnimationEnd);\n      return () => {\n        node.removeEventListener('animationstart', handleAnimationStart);\n        node.removeEventListener('animationcancel', handleAnimationEnd);\n        node.removeEventListener('animationend', handleAnimationEnd);\n      };\n    } else {\n      // Transition to the unmounted state if the node is removed prematurely.\n      // We avoid doing so during cleanup as the node may change but still exist.\n      send('ANIMATION_END');\n    }\n  }, [node, send]);\n\n  return {\n    isPresent: ['mounted', 'unmountSuspended'].includes(state),\n    ref: React.useCallback((node: HTMLElement) => {\n      if (node) stylesRef.current = getComputedStyle(node);\n      setNode(node);\n    }, []),\n  };\n}\n\n/* -----------------------------------------------------------------------------------------------*/\n\nfunction getAnimationName(styles?: CSSStyleDeclaration) {\n  return styles?.animationName || 'none';\n}\n\nexport { Presence };\nexport type { PresenceProps };\n","import * as React from 'react';\n\ntype Machine<S> = { [k: string]: { [k: string]: S } };\ntype MachineState<T> = keyof T;\ntype MachineEvent<T> = keyof UnionToIntersection<T[keyof T]>;\n\n// 🤯 https://fettblog.eu/typescript-union-to-intersection/\ntype UnionToIntersection<T> = (T extends any ? (x: T) => any : never) extends (x: infer R) => any\n  ? R\n  : never;\n\nexport function useStateMachine<M>(\n  initialState: MachineState<M>,\n  machine: M & Machine<MachineState<M>>\n) {\n  return React.useReducer((state: MachineState<M>, event: MachineEvent<M>): MachineState<M> => {\n    const nextState = (machine[state] as any)[event];\n    return nextState ?? state;\n  }, initialState);\n}\n"]},"metadata":{},"sourceType":"module"}