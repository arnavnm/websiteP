{"ast":null,"code":"/**\n * Given an input string, splits based on the delimiter after a given\n * number of delimiters has been encountered.\n *\n * @param value The input string to split.\n * @param delimiter The delimiter to split on.\n * @param numDelimiters The number of delimiters to have encountered to split.\n */\nexport function splitEvery(value, delimiter, numDelimiters) {\n  // Fail if we don't have a clear number to split on.\n  if (numDelimiters <= 0 || !Number.isInteger(numDelimiters)) {\n    throw new Error(\"Invalid number of delimiters (\" + numDelimiters + \") for splitEvery.\");\n  }\n\n  var segments = value.split(delimiter); // Short circuit extra logic for the simple case.\n\n  if (numDelimiters === 1) {\n    return segments;\n  }\n\n  var compoundSegments = [];\n  var currentSegment = \"\";\n\n  for (var i = 0; i < segments.length; i++) {\n    if (currentSegment === \"\") {\n      // Start a new segment.\n      currentSegment = segments[i];\n    } else {\n      // Compound the current segment with the delimiter.\n      currentSegment += delimiter + segments[i];\n    }\n\n    if ((i + 1) % numDelimiters === 0) {\n      // We encountered the right number of delimiters, so add the entry.\n      compoundSegments.push(currentSegment); // And reset the current segment.\n\n      currentSegment = \"\";\n    }\n  } // Handle any leftover segment portion.\n\n\n  if (currentSegment !== \"\") {\n    compoundSegments.push(currentSegment);\n  }\n\n  return compoundSegments;\n}","map":{"version":3,"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASA,UAAT,CAAoBC,KAApB,EAA2BC,SAA3B,EAAsCC,aAAtC,EAAqD;EACxD;EACA,IAAIA,aAAa,IAAI,CAAjB,IAAsB,CAACC,MAAM,CAACC,SAAP,CAAiBF,aAAjB,CAA3B,EAA4D;IACxD,MAAM,IAAIG,KAAJ,CAAU,mCAAmCH,aAAnC,GAAmD,mBAA7D,CAAN;EACH;;EACD,IAAII,QAAQ,GAAGN,KAAK,CAACO,KAAN,CAAYN,SAAZ,CAAf,CALwD,CAMxD;;EACA,IAAIC,aAAa,KAAK,CAAtB,EAAyB;IACrB,OAAOI,QAAP;EACH;;EACD,IAAIE,gBAAgB,GAAG,EAAvB;EACA,IAAIC,cAAc,GAAG,EAArB;;EACA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,QAAQ,CAACK,MAA7B,EAAqCD,CAAC,EAAtC,EAA0C;IACtC,IAAID,cAAc,KAAK,EAAvB,EAA2B;MACvB;MACAA,cAAc,GAAGH,QAAQ,CAACI,CAAD,CAAzB;IACH,CAHD,MAIK;MACD;MACAD,cAAc,IAAIR,SAAS,GAAGK,QAAQ,CAACI,CAAD,CAAtC;IACH;;IACD,IAAI,CAACA,CAAC,GAAG,CAAL,IAAUR,aAAV,KAA4B,CAAhC,EAAmC;MAC/B;MACAM,gBAAgB,CAACI,IAAjB,CAAsBH,cAAtB,EAF+B,CAG/B;;MACAA,cAAc,GAAG,EAAjB;IACH;EACJ,CA3BuD,CA4BxD;;;EACA,IAAIA,cAAc,KAAK,EAAvB,EAA2B;IACvBD,gBAAgB,CAACI,IAAjB,CAAsBH,cAAtB;EACH;;EACD,OAAOD,gBAAP;AACH","names":["splitEvery","value","delimiter","numDelimiters","Number","isInteger","Error","segments","split","compoundSegments","currentSegment","i","length","push"],"sources":["/Users/arnavmisra/Desktop/Portfolio-main/Portfolio/node_modules/@aws-sdk/smithy-client/src/split-every.ts"],"sourcesContent":["/**\n * Given an input string, splits based on the delimiter after a given\n * number of delimiters has been encountered.\n *\n * @param value The input string to split.\n * @param delimiter The delimiter to split on.\n * @param numDelimiters The number of delimiters to have encountered to split.\n */\nexport function splitEvery(value: string, delimiter: string, numDelimiters: number): Array<string> {\n  // Fail if we don't have a clear number to split on.\n  if (numDelimiters <= 0 || !Number.isInteger(numDelimiters)) {\n    throw new Error(\"Invalid number of delimiters (\" + numDelimiters + \") for splitEvery.\");\n  }\n\n  const segments = value.split(delimiter);\n  // Short circuit extra logic for the simple case.\n  if (numDelimiters === 1) {\n    return segments;\n  }\n\n  const compoundSegments: Array<string> = [];\n  let currentSegment = \"\";\n  for (let i = 0; i < segments.length; i++) {\n    if (currentSegment === \"\") {\n      // Start a new segment.\n      currentSegment = segments[i];\n    } else {\n      // Compound the current segment with the delimiter.\n      currentSegment += delimiter + segments[i];\n    }\n\n    if ((i + 1) % numDelimiters === 0) {\n      // We encountered the right number of delimiters, so add the entry.\n      compoundSegments.push(currentSegment);\n      // And reset the current segment.\n      currentSegment = \"\";\n    }\n  }\n\n  // Handle any leftover segment portion.\n  if (currentSegment !== \"\") {\n    compoundSegments.push(currentSegment);\n  }\n\n  return compoundSegments;\n}\n"]},"metadata":{},"sourceType":"module"}