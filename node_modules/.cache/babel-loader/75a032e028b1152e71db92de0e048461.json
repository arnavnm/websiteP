{"ast":null,"code":"/*\n * Copyright 2017-2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"). You may not use this file except in compliance with\n * the License. A copy of the License is located at\n *\n *     http://aws.amazon.com/apache2.0/\n *\n * or in the \"license\" file accompanying this file. This file is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions\n * and limitations under the License.\n */\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {\n      ar.push(r.value);\n    }\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nimport { ConsoleLogger as Logger, Parser } from '@aws-amplify/core';\nimport { AWSS3Provider } from './providers';\nimport axios from 'axios';\nimport { AWSS3UploadTask } from './providers/AWSS3UploadTask';\nvar logger = new Logger('StorageClass');\nvar DEFAULT_PROVIDER = 'AWSS3';\n/**\n * Provide storage methods to use AWS S3\n */\n\nvar Storage =\n/** @class */\nfunction () {\n  /**\n   * Initialize Storage\n   * @param {Object} config - Configuration object for storage\n   */\n  function Storage() {\n    this._config = {};\n    this._pluggables = [];\n    this._cancelTokenSourceMap = new WeakMap();\n    logger.debug('Storage Options', this._config);\n    this.get = this.get.bind(this);\n    this.put = this.put.bind(this);\n    this.remove = this.remove.bind(this);\n    this.list = this.list.bind(this);\n  }\n\n  Storage.prototype.getModuleName = function () {\n    return 'Storage';\n  };\n  /**\n   * add plugin into Storage category\n   * @param {Object} pluggable - an instance of the plugin\n   */\n\n\n  Storage.prototype.addPluggable = function (pluggable) {\n    if (pluggable && pluggable.getCategory() === 'Storage') {\n      this._pluggables.push(pluggable);\n\n      var config = {};\n      config = pluggable.configure(this._config[pluggable.getProviderName()]);\n      return config;\n    }\n  };\n  /**\n   * Get the plugin object\n   * @param providerName - the name of the plugin\n   */\n\n\n  Storage.prototype.getPluggable = function (providerName) {\n    var pluggable = this._pluggables.find(function (pluggable) {\n      return pluggable.getProviderName() === providerName;\n    });\n\n    if (pluggable === undefined) {\n      logger.debug('No plugin found with providerName', providerName);\n      return null;\n    } else return pluggable;\n  };\n  /**\n   * Remove the plugin object\n   * @param providerName - the name of the plugin\n   */\n\n\n  Storage.prototype.removePluggable = function (providerName) {\n    this._pluggables = this._pluggables.filter(function (pluggable) {\n      return pluggable.getProviderName() !== providerName;\n    });\n    return;\n  };\n  /**\n   * Configure Storage\n   * @param {Object} config - Configuration object for storage\n   * @return {Object} - Current configuration\n   */\n\n\n  Storage.prototype.configure = function (config) {\n    var _this = this;\n\n    logger.debug('configure Storage');\n    if (!config) return this._config;\n    var amplifyConfig = Parser.parseMobilehubConfig(config);\n    var storageKeysFromConfig = Object.keys(amplifyConfig.Storage);\n    var storageArrayKeys = ['bucket', 'region', 'level', 'track', 'customPrefix', 'serverSideEncryption', 'SSECustomerAlgorithm', 'SSECustomerKey', 'SSECustomerKeyMD5', 'SSEKMSKeyId'];\n\n    var isInStorageArrayKeys = function isInStorageArrayKeys(k) {\n      return storageArrayKeys.some(function (x) {\n        return x === k;\n      });\n    };\n\n    var checkConfigKeysFromArray = function checkConfigKeysFromArray(k) {\n      return k.find(function (k) {\n        return isInStorageArrayKeys(k);\n      });\n    };\n\n    if (storageKeysFromConfig && checkConfigKeysFromArray(storageKeysFromConfig) && !amplifyConfig.Storage[DEFAULT_PROVIDER]) {\n      amplifyConfig.Storage[DEFAULT_PROVIDER] = {};\n    }\n\n    Object.entries(amplifyConfig.Storage).map(function (_a) {\n      var _b = __read(_a, 2),\n          key = _b[0],\n          value = _b[1];\n\n      if (key && isInStorageArrayKeys(key) && value !== undefined) {\n        amplifyConfig.Storage[DEFAULT_PROVIDER][key] = value;\n        delete amplifyConfig.Storage[key];\n      }\n    }); // only update new values for each provider\n\n    Object.keys(amplifyConfig.Storage).forEach(function (providerName) {\n      if (typeof amplifyConfig.Storage[providerName] !== 'string') {\n        _this._config[providerName] = __assign(__assign({}, _this._config[providerName]), amplifyConfig.Storage[providerName]);\n      }\n    });\n\n    this._pluggables.forEach(function (pluggable) {\n      pluggable.configure(_this._config[pluggable.getProviderName()]);\n    });\n\n    if (this._pluggables.length === 0) {\n      this.addPluggable(new AWSS3Provider());\n    }\n\n    return this._config;\n  };\n\n  Storage.prototype.getCancellableTokenSource = function () {\n    return axios.CancelToken.source();\n  };\n\n  Storage.prototype.updateRequestToBeCancellable = function (request, cancelTokenSource) {\n    this._cancelTokenSourceMap.set(request, cancelTokenSource);\n  };\n\n  Storage.prototype.isUploadTask = function (x) {\n    return typeof x !== 'undefined' && typeof x['pause'] === 'function' && typeof x['resume'] === 'function';\n  };\n\n  Storage.prototype.cancel = function (request, message) {\n    if (request instanceof AWSS3UploadTask) {\n      return request._cancel();\n    }\n\n    var cancelTokenSource = this._cancelTokenSourceMap.get(request);\n\n    if (cancelTokenSource) {\n      cancelTokenSource.cancel(message);\n    } else {\n      logger.debug('The request does not map to any cancel token');\n    }\n  };\n\n  Storage.prototype.copy = function (src, dest, config) {\n    var provider = (config === null || config === void 0 ? void 0 : config.provider) || DEFAULT_PROVIDER;\n\n    var prov = this._pluggables.find(function (pluggable) {\n      return pluggable.getProviderName() === provider;\n    });\n\n    if (prov === undefined) {\n      logger.debug('No plugin found with providerName', provider);\n      return Promise.reject('No plugin found in Storage for the provider');\n    }\n\n    var cancelTokenSource = this.getCancellableTokenSource();\n\n    if (typeof prov.copy !== 'function') {\n      return Promise.reject(\".copy is not implemented on provider \" + prov.getProviderName());\n    }\n\n    var responsePromise = prov.copy(src, dest, __assign(__assign({}, config), {\n      cancelTokenSource: cancelTokenSource\n    }));\n    this.updateRequestToBeCancellable(responsePromise, cancelTokenSource);\n    return responsePromise;\n  };\n\n  Storage.prototype.get = function (key, config) {\n    var provider = (config === null || config === void 0 ? void 0 : config.provider) || DEFAULT_PROVIDER;\n\n    var prov = this._pluggables.find(function (pluggable) {\n      return pluggable.getProviderName() === provider;\n    });\n\n    if (prov === undefined) {\n      logger.debug('No plugin found with providerName', provider);\n      return Promise.reject('No plugin found in Storage for the provider');\n    }\n\n    var cancelTokenSource = this.getCancellableTokenSource();\n    var responsePromise = prov.get(key, __assign(__assign({}, config), {\n      cancelTokenSource: cancelTokenSource\n    }));\n    this.updateRequestToBeCancellable(responsePromise, cancelTokenSource);\n    return responsePromise;\n  };\n\n  Storage.prototype.isCancelError = function (error) {\n    return axios.isCancel(error);\n  };\n\n  Storage.prototype.put = function (key, object, config) {\n    var provider = (config === null || config === void 0 ? void 0 : config.provider) || DEFAULT_PROVIDER;\n\n    var prov = this._pluggables.find(function (pluggable) {\n      return pluggable.getProviderName() === provider;\n    });\n\n    if (prov === undefined) {\n      logger.debug('No plugin found with providerName', provider);\n      return Promise.reject('No plugin found in Storage for the provider');\n    }\n\n    var cancelTokenSource = this.getCancellableTokenSource();\n    var response = prov.put(key, object, __assign(__assign({}, config), {\n      cancelTokenSource: cancelTokenSource\n    }));\n\n    if (!this.isUploadTask(response)) {\n      this.updateRequestToBeCancellable(response, cancelTokenSource);\n    }\n\n    return response;\n  };\n\n  Storage.prototype.remove = function (key, config) {\n    var provider = (config === null || config === void 0 ? void 0 : config.provider) || DEFAULT_PROVIDER;\n\n    var prov = this._pluggables.find(function (pluggable) {\n      return pluggable.getProviderName() === provider;\n    });\n\n    if (prov === undefined) {\n      logger.debug('No plugin found with providerName', provider);\n      return Promise.reject('No plugin found in Storage for the provider');\n    }\n\n    return prov.remove(key, config);\n  };\n\n  Storage.prototype.list = function (path, config) {\n    var provider = (config === null || config === void 0 ? void 0 : config.provider) || DEFAULT_PROVIDER;\n\n    var prov = this._pluggables.find(function (pluggable) {\n      return pluggable.getProviderName() === provider;\n    });\n\n    if (prov === undefined) {\n      logger.debug('No plugin found with providerName', provider);\n      return Promise.reject('No plugin found in Storage for the provider');\n    }\n\n    return prov.list(path, config);\n  };\n\n  return Storage;\n}();\n\nexport { Storage };\n/**\n * @deprecated use named import\n */\n\nexport default Storage;","map":{"version":3,"mappings":"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","names":["ConsoleLogger","Logger","Parser","AWSS3Provider","axios","AWSS3UploadTask","logger","DEFAULT_PROVIDER","_config","_pluggables","_cancelTokenSourceMap","WeakMap","debug","get","bind","put","remove","list","Storage","pluggable","getCategory","push","config","configure","getProviderName","providerName","find","undefined","filter","amplifyConfig","parseMobilehubConfig","storageKeysFromConfig","Object","keys","storageArrayKeys","isInStorageArrayKeys","k","some","checkConfigKeysFromArray","entries","map","_a","_b","key","value","forEach","_this","__assign","length","addPluggable","CancelToken","source","request","cancelTokenSource","set","x","message","_cancel","cancel","src","dest","provider","prov","Promise","reject","getCancellableTokenSource","copy","responsePromise","updateRequestToBeCancellable","error","isCancel","object","response","isUploadTask","path"],"sources":["/Users/arnavmisra/Desktop/Portfolio-main/Portfolio/node_modules/@aws-amplify/storage/src/Storage.ts"],"sourcesContent":["/*\n * Copyright 2017-2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"). You may not use this file except in compliance with\n * the License. A copy of the License is located at\n *\n *     http://aws.amazon.com/apache2.0/\n *\n * or in the \"license\" file accompanying this file. This file is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions\n * and limitations under the License.\n */\n\nimport { ConsoleLogger as Logger, Parser } from '@aws-amplify/core';\nimport { AWSS3Provider } from './providers';\nimport {\n\tStorageCopySource,\n\tStorageCopyDestination,\n\tStorageGetConfig,\n\tStorageProvider,\n\tStoragePutConfig,\n\tStorageRemoveConfig,\n\tStorageListConfig,\n\tStorageCopyConfig,\n\tStorageProviderWithCopy,\n\tStorageGetOutput,\n\tStoragePutOutput,\n\tStorageRemoveOutput,\n\tStorageListOutput,\n\tStorageCopyOutput,\n\tUploadTask,\n} from './types';\nimport axios, { CancelTokenSource } from 'axios';\nimport { PutObjectCommandInput } from '@aws-sdk/client-s3';\nimport { AWSS3UploadTask } from './providers/AWSS3UploadTask';\n\nconst logger = new Logger('StorageClass');\n\nconst DEFAULT_PROVIDER = 'AWSS3';\n/**\n * Provide storage methods to use AWS S3\n */\nexport class Storage {\n\t/**\n\t * @private\n\t */\n\tprivate _config;\n\tprivate _pluggables: StorageProvider[];\n\n\t/**\n\t * Similar to the API module. This weak map allows users to cancel their in-flight request made using the Storage\n\t * module. For every get or put request, a unique cancel token will be generated and injected to it's underlying\n\t * AxiosHttpHandler. This map maintains a mapping of Request to CancelTokenSource. When .cancel is invoked, it will\n\t * attempt to retrieve it's corresponding cancelTokenSource and cancel the in-flight request.\n\t */\n\tprivate _cancelTokenSourceMap: WeakMap<Promise<any>, CancelTokenSource>;\n\n\t/**\n\t * @public\n\t */\n\tpublic vault: Storage;\n\n\t/**\n\t * Initialize Storage\n\t * @param {Object} config - Configuration object for storage\n\t */\n\tconstructor() {\n\t\tthis._config = {};\n\t\tthis._pluggables = [];\n\t\tthis._cancelTokenSourceMap = new WeakMap<Promise<any>, CancelTokenSource>();\n\t\tlogger.debug('Storage Options', this._config);\n\n\t\tthis.get = this.get.bind(this);\n\t\tthis.put = this.put.bind(this);\n\t\tthis.remove = this.remove.bind(this);\n\t\tthis.list = this.list.bind(this);\n\t}\n\n\tpublic getModuleName() {\n\t\treturn 'Storage';\n\t}\n\n\t/**\n\t * add plugin into Storage category\n\t * @param {Object} pluggable - an instance of the plugin\n\t */\n\tpublic addPluggable(pluggable: StorageProvider) {\n\t\tif (pluggable && pluggable.getCategory() === 'Storage') {\n\t\t\tthis._pluggables.push(pluggable);\n\t\t\tlet config = {};\n\n\t\t\tconfig = pluggable.configure(this._config[pluggable.getProviderName()]);\n\n\t\t\treturn config;\n\t\t}\n\t}\n\n\t/**\n\t * Get the plugin object\n\t * @param providerName - the name of the plugin\n\t */\n\tpublic getPluggable(providerName: string) {\n\t\tconst pluggable = this._pluggables.find(\n\t\t\tpluggable => pluggable.getProviderName() === providerName\n\t\t);\n\t\tif (pluggable === undefined) {\n\t\t\tlogger.debug('No plugin found with providerName', providerName);\n\t\t\treturn null;\n\t\t} else return pluggable;\n\t}\n\n\t/**\n\t * Remove the plugin object\n\t * @param providerName - the name of the plugin\n\t */\n\tpublic removePluggable(providerName: string) {\n\t\tthis._pluggables = this._pluggables.filter(\n\t\t\tpluggable => pluggable.getProviderName() !== providerName\n\t\t);\n\t\treturn;\n\t}\n\n\t/**\n\t * Configure Storage\n\t * @param {Object} config - Configuration object for storage\n\t * @return {Object} - Current configuration\n\t */\n\tconfigure(config?) {\n\t\tlogger.debug('configure Storage');\n\t\tif (!config) return this._config;\n\n\t\tconst amplifyConfig = Parser.parseMobilehubConfig(config);\n\n\t\tconst storageKeysFromConfig = Object.keys(amplifyConfig.Storage);\n\n\t\tconst storageArrayKeys = [\n\t\t\t'bucket',\n\t\t\t'region',\n\t\t\t'level',\n\t\t\t'track',\n\t\t\t'customPrefix',\n\t\t\t'serverSideEncryption',\n\t\t\t'SSECustomerAlgorithm',\n\t\t\t'SSECustomerKey',\n\t\t\t'SSECustomerKeyMD5',\n\t\t\t'SSEKMSKeyId',\n\t\t];\n\n\t\tconst isInStorageArrayKeys = (k: string) =>\n\t\t\tstorageArrayKeys.some(x => x === k);\n\t\tconst checkConfigKeysFromArray = (k: string[]) =>\n\t\t\tk.find(k => isInStorageArrayKeys(k));\n\n\t\tif (\n\t\t\tstorageKeysFromConfig &&\n\t\t\tcheckConfigKeysFromArray(storageKeysFromConfig) &&\n\t\t\t!amplifyConfig.Storage[DEFAULT_PROVIDER]\n\t\t) {\n\t\t\tamplifyConfig.Storage[DEFAULT_PROVIDER] = {};\n\t\t}\n\n\t\tObject.entries(amplifyConfig.Storage).map(([key, value]) => {\n\t\t\tif (key && isInStorageArrayKeys(key) && value !== undefined) {\n\t\t\t\tamplifyConfig.Storage[DEFAULT_PROVIDER][key] = value;\n\t\t\t\tdelete amplifyConfig.Storage[key];\n\t\t\t}\n\t\t});\n\n\t\t// only update new values for each provider\n\t\tObject.keys(amplifyConfig.Storage).forEach(providerName => {\n\t\t\tif (typeof amplifyConfig.Storage[providerName] !== 'string') {\n\t\t\t\tthis._config[providerName] = {\n\t\t\t\t\t...this._config[providerName],\n\t\t\t\t\t...amplifyConfig.Storage[providerName],\n\t\t\t\t};\n\t\t\t}\n\t\t});\n\n\t\tthis._pluggables.forEach(pluggable => {\n\t\t\tpluggable.configure(this._config[pluggable.getProviderName()]);\n\t\t});\n\n\t\tif (this._pluggables.length === 0) {\n\t\t\tthis.addPluggable(new AWSS3Provider());\n\t\t}\n\n\t\treturn this._config;\n\t}\n\n\tprivate getCancellableTokenSource(): CancelTokenSource {\n\t\treturn axios.CancelToken.source();\n\t}\n\n\tprivate updateRequestToBeCancellable(\n\t\trequest: Promise<any>,\n\t\tcancelTokenSource: CancelTokenSource\n\t) {\n\t\tthis._cancelTokenSourceMap.set(request, cancelTokenSource);\n\t}\n\n\tprivate isUploadTask(x: unknown): x is UploadTask {\n\t\treturn (\n\t\t\ttypeof x !== 'undefined' &&\n\t\t\ttypeof x['pause'] === 'function' &&\n\t\t\ttypeof x['resume'] === 'function'\n\t\t);\n\t}\n\n\t/**\n\t * Cancels an inflight request\n\t *\n\t * @param request - The request to cancel\n\t * @param [message] - A message to include in the cancelation exception\n\t */\n\tpublic cancel(request: UploadTask, message?: string): Promise<boolean>;\n\tpublic cancel(request: Promise<any>, message?: string): void;\n\tpublic cancel(\n\t\trequest: Promise<any> | UploadTask,\n\t\tmessage?: string\n\t): void | Promise<boolean> {\n\t\tif (request instanceof AWSS3UploadTask) {\n\t\t\treturn request._cancel();\n\t\t}\n\t\tconst cancelTokenSource = this._cancelTokenSourceMap.get(\n\t\t\trequest as Promise<any>\n\t\t);\n\t\tif (cancelTokenSource) {\n\t\t\tcancelTokenSource.cancel(message);\n\t\t} else {\n\t\t\tlogger.debug('The request does not map to any cancel token');\n\t\t}\n\t}\n\n\t/**\n\t * Copies a file from src to dest.\n\t *\n\t * @param src - The source object.\n\t * @param dest - The destination object.\n\t * @param [config] - config for the Storage operation.\n\t * @return A promise resolves to the copied object's key.\n\t */\n\tpublic copy<T extends Record<string, any>>(\n\t\tsrc: StorageCopySource,\n\t\tdest: StorageCopyDestination,\n\t\tconfig?: StorageCopyConfig<T>\n\t): StorageCopyOutput<T>;\n\tpublic copy<T extends StorageProviderWithCopy = AWSS3Provider>(\n\t\tsrc: Parameters<T['copy']>[0],\n\t\tdest: Parameters<T['copy']>[1],\n\t\tconfig?: StorageCopyConfig<T>\n\t): StorageCopyOutput<T> {\n\t\tconst provider = config?.provider || DEFAULT_PROVIDER;\n\t\tconst prov = this._pluggables.find(\n\t\t\tpluggable => pluggable.getProviderName() === provider\n\t\t);\n\t\tif (prov === undefined) {\n\t\t\tlogger.debug('No plugin found with providerName', provider);\n\t\t\treturn Promise.reject(\n\t\t\t\t'No plugin found in Storage for the provider'\n\t\t\t) as StorageCopyOutput<T>;\n\t\t}\n\t\tconst cancelTokenSource = this.getCancellableTokenSource();\n\t\tif (typeof prov.copy !== 'function') {\n\t\t\treturn Promise.reject(\n\t\t\t\t`.copy is not implemented on provider ${prov.getProviderName()}`\n\t\t\t) as StorageCopyOutput<T>;\n\t\t}\n\t\tconst responsePromise = prov.copy(src, dest, {\n\t\t\t...config,\n\t\t\tcancelTokenSource,\n\t\t});\n\t\tthis.updateRequestToBeCancellable(responsePromise, cancelTokenSource);\n\t\treturn responsePromise as StorageCopyOutput<T>;\n\t}\n\n\t/**\n\t * Get a presigned URL of the file or the object data when download:true\n\t *\n\t * @param key - key of the object\n\t * @param [config] - config for the Storage operation.\n\t * @return - A promise resolves to either a presigned url or the object\n\t */\n\t// Adding & { download?: boolean }, if not T extends { download: true } ? ... : ... will not work properly\n\tpublic get<T extends Record<string, any> & { download?: boolean }>(\n\t\tkey: string,\n\t\tconfig?: StorageGetConfig<T>\n\t): StorageGetOutput<T>;\n\tpublic get<\n\t\tT extends StorageProvider | { [key: string]: any; download?: boolean }\n\t>(key: string, config?: StorageGetConfig<T>): StorageGetOutput<T> {\n\t\tconst provider = config?.provider || DEFAULT_PROVIDER;\n\t\tconst prov = this._pluggables.find(\n\t\t\tpluggable => pluggable.getProviderName() === provider\n\t\t);\n\t\tif (prov === undefined) {\n\t\t\tlogger.debug('No plugin found with providerName', provider);\n\t\t\treturn Promise.reject(\n\t\t\t\t'No plugin found in Storage for the provider'\n\t\t\t) as StorageGetOutput<T>;\n\t\t}\n\t\tconst cancelTokenSource = this.getCancellableTokenSource();\n\t\tconst responsePromise = prov.get(key, {\n\t\t\t...config,\n\t\t\tcancelTokenSource,\n\t\t});\n\t\tthis.updateRequestToBeCancellable(responsePromise, cancelTokenSource);\n\t\treturn responsePromise as StorageGetOutput<T>;\n\t}\n\n\tpublic isCancelError(error: any) {\n\t\treturn axios.isCancel(error);\n\t}\n\n\t/**\n\t * Put a file in storage bucket specified to configure method\n\t * @param key - key of the object\n\t * @param object - File to be put in bucket\n\t * @param [config] - { level : private|protected|public, contentType: MIME Types,\n\t *  progressCallback: function }\n\t * @return - promise resolves to object on success\n\t */\n\tpublic put<T extends Record<string, any>>(\n\t\tkey: string,\n\t\tobject: any,\n\t\tconfig?: StoragePutConfig<T>\n\t): StoragePutOutput<T>;\n\tpublic put<T extends StorageProvider = AWSS3Provider>(\n\t\tkey: string,\n\t\tobject: Omit<PutObjectCommandInput['Body'], 'ReadableStream' | 'Readable'>,\n\t\tconfig?: StoragePutConfig<T>\n\t): StoragePutOutput<T> {\n\t\tconst provider = config?.provider || DEFAULT_PROVIDER;\n\t\tconst prov = this._pluggables.find(\n\t\t\tpluggable => pluggable.getProviderName() === provider\n\t\t);\n\t\tif (prov === undefined) {\n\t\t\tlogger.debug('No plugin found with providerName', provider);\n\t\t\treturn Promise.reject(\n\t\t\t\t'No plugin found in Storage for the provider'\n\t\t\t) as StoragePutOutput<T>;\n\t\t}\n\t\tconst cancelTokenSource = this.getCancellableTokenSource();\n\t\tconst response = prov.put(key, object, {\n\t\t\t...config,\n\t\t\tcancelTokenSource,\n\t\t});\n\t\tif (!this.isUploadTask(response)) {\n\t\t\tthis.updateRequestToBeCancellable(response, cancelTokenSource);\n\t\t}\n\t\treturn response as StoragePutOutput<T>;\n\t}\n\n\t/**\n\t * Remove the object for specified key\n\t * @param key - key of the object\n\t * @param [config] - { level : private|protected|public }\n\t * @return - Promise resolves upon successful removal of the object\n\t */\n\tpublic remove<T extends Record<string, any>>(\n\t\tkey: string,\n\t\tconfig?: StorageRemoveConfig<T>\n\t): StorageRemoveOutput<T>;\n\tpublic remove<T extends StorageProvider = AWSS3Provider>(\n\t\tkey: string,\n\t\tconfig?: StorageRemoveConfig<T>\n\t): StorageRemoveOutput<T> {\n\t\tconst provider = config?.provider || DEFAULT_PROVIDER;\n\t\tconst prov = this._pluggables.find(\n\t\t\tpluggable => pluggable.getProviderName() === provider\n\t\t);\n\t\tif (prov === undefined) {\n\t\t\tlogger.debug('No plugin found with providerName', provider);\n\t\t\treturn Promise.reject(\n\t\t\t\t'No plugin found in Storage for the provider'\n\t\t\t) as StorageRemoveOutput<T>;\n\t\t}\n\t\treturn prov.remove(key, config) as StorageRemoveOutput<T>;\n\t}\n\n\t/**\n\t * List bucket objects relative to the level and prefix specified\n\t * @param path - the path that contains objects\n\t * @param [config] - { level : private|protected|public, maxKeys: NUMBER }\n\t * @return - Promise resolves to list of keys for all objects in path\n\t */\n\tpublic list<T extends Record<string, any>>(\n\t\tkey: string,\n\t\tconfig?: StorageListConfig<T>\n\t): StorageListOutput<T>;\n\tpublic list<T extends StorageProvider = AWSS3Provider>(\n\t\tpath: string,\n\t\tconfig?: StorageListConfig<T>\n\t): StorageListOutput<T> {\n\t\tconst provider = config?.provider || DEFAULT_PROVIDER;\n\t\tconst prov = this._pluggables.find(\n\t\t\tpluggable => pluggable.getProviderName() === provider\n\t\t);\n\t\tif (prov === undefined) {\n\t\t\tlogger.debug('No plugin found with providerName', provider);\n\t\t\treturn Promise.reject(\n\t\t\t\t'No plugin found in Storage for the provider'\n\t\t\t) as StorageListOutput<T>;\n\t\t}\n\t\treturn prov.list(path, config) as StorageListOutput<T>;\n\t}\n}\n\n/**\n * @deprecated use named import\n */\nexport default Storage;\n"]},"metadata":{},"sourceType":"module"}