{"ast":null,"code":"import { useCallbackRef as e } from \"@radix-ui/react-use-callback-ref\";\nimport { Primitive as t } from \"@radix-ui/react-primitive\";\nimport { useComposedRefs as n } from \"@radix-ui/react-compose-refs\";\nimport * as o from \"react\";\nimport u from \"@babel/runtime/helpers/esm/extends\";\nconst c = {\n  bubbles: !1,\n  cancelable: !0\n};\nexport const FocusScope = /*#__PURE__*/o.forwardRef((i, f) => {\n  const {\n    loop: l = !1,\n    trapped: m = !1,\n    onMountAutoFocus: p,\n    onUnmountAutoFocus: v,\n    ...E\n  } = i,\n        [F, S] = o.useState(null),\n        b = e(p),\n        T = e(v),\n        y = o.useRef(null),\n        L = n(f, e => S(e)),\n        h = o.useRef({\n    paused: !1,\n\n    pause() {\n      this.paused = !0;\n    },\n\n    resume() {\n      this.paused = !1;\n    }\n\n  }).current;\n  o.useEffect(() => {\n    if (m) {\n      function e(e) {\n        if (h.paused || !F) return;\n        const t = e.target;\n        F.contains(t) ? y.current = t : a(y.current, {\n          select: !0\n        });\n      }\n\n      function t(e) {\n        !h.paused && F && (F.contains(e.relatedTarget) || a(y.current, {\n          select: !0\n        }));\n      }\n\n      return document.addEventListener(\"focusin\", e), document.addEventListener(\"focusout\", t), () => {\n        document.removeEventListener(\"focusin\", e), document.removeEventListener(\"focusout\", t);\n      };\n    }\n  }, [m, F, h.paused]), o.useEffect(() => {\n    if (F) {\n      d.add(h);\n      const t = document.activeElement;\n\n      if (!F.contains(t)) {\n        const n = new Event(\"focusScope.autoFocusOnMount\", c);\n        F.addEventListener(\"focusScope.autoFocusOnMount\", b), F.dispatchEvent(n), n.defaultPrevented || (!function (e) {\n          let {\n            select: t = !1\n          } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n          const n = document.activeElement;\n\n          for (const o of e) if (a(o, {\n            select: t\n          }), document.activeElement !== n) return;\n        }((e = r(F), e.filter(e => \"A\" !== e.tagName)), {\n          select: !0\n        }), document.activeElement === t && a(F));\n      }\n\n      return () => {\n        F.removeEventListener(\"focusScope.autoFocusOnMount\", b), setTimeout(() => {\n          const e = new Event(\"focusScope.autoFocusOnUnmount\", c);\n          F.addEventListener(\"focusScope.autoFocusOnUnmount\", T), F.dispatchEvent(e), e.defaultPrevented || a(null != t ? t : document.body, {\n            select: !0\n          }), F.removeEventListener(\"focusScope.autoFocusOnUnmount\", T), d.remove(h);\n        }, 0);\n      };\n    }\n\n    var e;\n  }, [F, b, T, h]);\n  const N = o.useCallback(e => {\n    if (!l && !m) return;\n    if (h.paused) return;\n    const t = \"Tab\" === e.key && !e.altKey && !e.ctrlKey && !e.metaKey,\n          n = document.activeElement;\n\n    if (t && n) {\n      const t = e.currentTarget,\n            [o, u] = function (e) {\n        const t = r(e),\n              n = s(t, e),\n              o = s(t.reverse(), e);\n        return [n, o];\n      }(t);\n\n      o && u ? e.shiftKey || n !== u ? e.shiftKey && n === o && (e.preventDefault(), l && a(u, {\n        select: !0\n      })) : (e.preventDefault(), l && a(o, {\n        select: !0\n      })) : n === t && e.preventDefault();\n    }\n  }, [l, m, h.paused]);\n  /*#__PURE__*/\n\n  return o.createElement(t.div, u({\n    tabIndex: -1\n  }, E, {\n    ref: L,\n    onKeyDown: N\n  }));\n});\n/*#__PURE__*/\n\nfunction r(e) {\n  const t = [],\n        n = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, {\n    acceptNode: e => {\n      const t = \"INPUT\" === e.tagName && \"hidden\" === e.type;\n      return e.disabled || e.hidden || t ? NodeFilter.FILTER_SKIP : e.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n    }\n  });\n\n  for (; n.nextNode();) t.push(n.currentNode);\n\n  return t;\n}\n\nfunction s(e, t) {\n  for (const n of e) if (!i(n, {\n    upTo: t\n  })) return n;\n}\n\nfunction i(e, _ref) {\n  let {\n    upTo: t\n  } = _ref;\n  if (\"hidden\" === getComputedStyle(e).visibility) return !0;\n\n  for (; e;) {\n    if (void 0 !== t && e === t) return !1;\n    if (\"none\" === getComputedStyle(e).display) return !0;\n    e = e.parentElement;\n  }\n\n  return !1;\n}\n\nfunction a(e) {\n  let {\n    select: t = !1\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (e && e.focus) {\n    const n = document.activeElement;\n    e.focus({\n      preventScroll: !0\n    }), e !== n && function (e) {\n      return e instanceof HTMLInputElement && \"select\" in e;\n    }(e) && t && e.select();\n  }\n}\n\nconst d = function () {\n  let e = [];\n  return {\n    add(t) {\n      const n = e[0];\n      t !== n && (null == n || n.pause()), e = f(e, t), e.unshift(t);\n    },\n\n    remove(t) {\n      var n;\n      e = f(e, t), null === (n = e[0]) || void 0 === n || n.resume();\n    }\n\n  };\n}();\n\nfunction f(e, t) {\n  const n = [...e],\n        o = n.indexOf(t);\n  return -1 !== o && n.splice(o, 1), n;\n}\n\nexport const Root = FocusScope;","map":{"version":3,"mappings":"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","names":["EVENT_OPTIONS","bubbles","cancelable","FocusScope","React","forwardRef","props","forwardedRef","loop","trapped","onMountAutoFocus","onMountAutoFocusProp","onUnmountAutoFocus","onUnmountAutoFocusProp","scopeProps","container","setContainer","useState","useCallbackRef","lastFocusedElementRef","useRef","composedRefs","useComposedRefs","node","focusScope","paused","pause","this","resume","current","useEffect","handleFocusIn","event","target","contains","focus","select","handleFocusOut","relatedTarget","document","addEventListener","removeEventListener","focusScopesStack","add","previouslyFocusedElement","activeElement","mountEvent","Event","dispatchEvent","defaultPrevented","candidates","candidate","focusFirst","items","getTabbableCandidates","filter","item","tagName","setTimeout","unmountEvent","body","remove","handleKeyDown","useCallback","isTabKey","key","altKey","ctrlKey","metaKey","focusedElement","currentTarget","first","last","findVisible","reverse","getTabbableEdges","shiftKey","preventDefault","_react","Primitive","div","tabIndex","_babelRuntimeHelpersEsmExtends","ref","onKeyDown","nodes","walker","createTreeWalker","NodeFilter","SHOW_ELEMENT","acceptNode","isHiddenInput","type","disabled","hidden","FILTER_SKIP","FILTER_ACCEPT","nextNode","push","currentNode","elements","element","isHidden","upTo","getComputedStyle","visibility","undefined","display","parentElement","preventScroll","HTMLInputElement","isSelectableInput","stack","activeFocusScope","arrayRemove","unshift","_stack$","createFocusScopesStack","array","updatedArray","index","indexOf","splice","Root"],"sources":["/Users/arnavmisra/Desktop/Portfolio-main/node_modules/@radix-ui/react-focus-scope/dist/packages/react/focus-scope/src/FocusScope.tsx"],"sourcesContent":["import * as React from 'react';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { Primitive } from '@radix-ui/react-primitive';\nimport { useCallbackRef } from '@radix-ui/react-use-callback-ref';\n\nimport type * as Radix from '@radix-ui/react-primitive';\n\nconst AUTOFOCUS_ON_MOUNT = 'focusScope.autoFocusOnMount';\nconst AUTOFOCUS_ON_UNMOUNT = 'focusScope.autoFocusOnUnmount';\nconst EVENT_OPTIONS = { bubbles: false, cancelable: true };\n\ntype FocusableTarget = HTMLElement | { focus(): void };\n\n/* -------------------------------------------------------------------------------------------------\n * FocusScope\n * -----------------------------------------------------------------------------------------------*/\n\nconst FOCUS_SCOPE_NAME = 'FocusScope';\n\ntype FocusScopeElement = React.ElementRef<typeof Primitive.div>;\ntype PrimitiveDivProps = Radix.ComponentPropsWithoutRef<typeof Primitive.div>;\ninterface FocusScopeProps extends PrimitiveDivProps {\n  /**\n   * When `true`, tabbing from last item will focus first tabbable\n   * and shift+tab from first item will focus last tababble.\n   * @defaultValue false\n   */\n  loop?: boolean;\n\n  /**\n   * When `true`, focus cannot escape the focus scope via keyboard,\n   * pointer, or a programmatic focus.\n   * @defaultValue false\n   */\n  trapped?: boolean;\n\n  /**\n   * Event handler called when auto-focusing on mount.\n   * Can be prevented.\n   */\n  onMountAutoFocus?: (event: Event) => void;\n\n  /**\n   * Event handler called when auto-focusing on unmount.\n   * Can be prevented.\n   */\n  onUnmountAutoFocus?: (event: Event) => void;\n}\n\nconst FocusScope = React.forwardRef<FocusScopeElement, FocusScopeProps>((props, forwardedRef) => {\n  const {\n    loop = false,\n    trapped = false,\n    onMountAutoFocus: onMountAutoFocusProp,\n    onUnmountAutoFocus: onUnmountAutoFocusProp,\n    ...scopeProps\n  } = props;\n  const [container, setContainer] = React.useState<HTMLElement | null>(null);\n  const onMountAutoFocus = useCallbackRef(onMountAutoFocusProp);\n  const onUnmountAutoFocus = useCallbackRef(onUnmountAutoFocusProp);\n  const lastFocusedElementRef = React.useRef<HTMLElement | null>(null);\n  const composedRefs = useComposedRefs(forwardedRef, (node) => setContainer(node));\n\n  const focusScope = React.useRef({\n    paused: false,\n    pause() {\n      this.paused = true;\n    },\n    resume() {\n      this.paused = false;\n    },\n  }).current;\n\n  // Takes care of trapping focus if focus is moved outside programmatically for example\n  React.useEffect(() => {\n    if (trapped) {\n      function handleFocusIn(event: FocusEvent) {\n        if (focusScope.paused || !container) return;\n        const target = event.target as HTMLElement | null;\n        if (container.contains(target)) {\n          lastFocusedElementRef.current = target;\n        } else {\n          focus(lastFocusedElementRef.current, { select: true });\n        }\n      }\n\n      function handleFocusOut(event: FocusEvent) {\n        if (focusScope.paused || !container) return;\n        if (!container.contains(event.relatedTarget as HTMLElement | null)) {\n          focus(lastFocusedElementRef.current, { select: true });\n        }\n      }\n\n      document.addEventListener('focusin', handleFocusIn);\n      document.addEventListener('focusout', handleFocusOut);\n      return () => {\n        document.removeEventListener('focusin', handleFocusIn);\n        document.removeEventListener('focusout', handleFocusOut);\n      };\n    }\n  }, [trapped, container, focusScope.paused]);\n\n  React.useEffect(() => {\n    if (container) {\n      focusScopesStack.add(focusScope);\n      const previouslyFocusedElement = document.activeElement as HTMLElement | null;\n      const hasFocusedCandidate = container.contains(previouslyFocusedElement);\n\n      if (!hasFocusedCandidate) {\n        const mountEvent = new Event(AUTOFOCUS_ON_MOUNT, EVENT_OPTIONS);\n        container.addEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);\n        container.dispatchEvent(mountEvent);\n        if (!mountEvent.defaultPrevented) {\n          focusFirst(removeLinks(getTabbableCandidates(container)), { select: true });\n          if (document.activeElement === previouslyFocusedElement) {\n            focus(container);\n          }\n        }\n      }\n\n      return () => {\n        container.removeEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);\n\n        // We hit a react bug (fixed in v17) with focusing in unmount.\n        // We need to delay the focus a little to get around it for now.\n        // See: https://github.com/facebook/react/issues/17894\n        setTimeout(() => {\n          const unmountEvent = new Event(AUTOFOCUS_ON_UNMOUNT, EVENT_OPTIONS);\n          container.addEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);\n          container.dispatchEvent(unmountEvent);\n          if (!unmountEvent.defaultPrevented) {\n            focus(previouslyFocusedElement ?? document.body, { select: true });\n          }\n          // we need to remove the listener after we `dispatchEvent`\n          container.removeEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);\n\n          focusScopesStack.remove(focusScope);\n        }, 0);\n      };\n    }\n  }, [container, onMountAutoFocus, onUnmountAutoFocus, focusScope]);\n\n  // Takes care of looping focus (when tabbing whilst at the edges)\n  const handleKeyDown = React.useCallback(\n    (event: React.KeyboardEvent) => {\n      if (!loop && !trapped) return;\n      if (focusScope.paused) return;\n\n      const isTabKey = event.key === 'Tab' && !event.altKey && !event.ctrlKey && !event.metaKey;\n      const focusedElement = document.activeElement as HTMLElement | null;\n\n      if (isTabKey && focusedElement) {\n        const container = event.currentTarget as HTMLElement;\n        const [first, last] = getTabbableEdges(container);\n        const hasTabbableElementsInside = first && last;\n\n        // we can only wrap focus if we have tabbable edges\n        if (!hasTabbableElementsInside) {\n          if (focusedElement === container) event.preventDefault();\n        } else {\n          if (!event.shiftKey && focusedElement === last) {\n            event.preventDefault();\n            if (loop) focus(first, { select: true });\n          } else if (event.shiftKey && focusedElement === first) {\n            event.preventDefault();\n            if (loop) focus(last, { select: true });\n          }\n        }\n      }\n    },\n    [loop, trapped, focusScope.paused]\n  );\n\n  return (\n    <Primitive.div tabIndex={-1} {...scopeProps} ref={composedRefs} onKeyDown={handleKeyDown} />\n  );\n});\n\nFocusScope.displayName = FOCUS_SCOPE_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * Utils\n * -----------------------------------------------------------------------------------------------*/\n\n/**\n * Attempts focusing the first element in a list of candidates.\n * Stops when focus has actually moved.\n */\nfunction focusFirst(candidates: HTMLElement[], { select = false } = {}) {\n  const previouslyFocusedElement = document.activeElement;\n  for (const candidate of candidates) {\n    focus(candidate, { select });\n    if (document.activeElement !== previouslyFocusedElement) return;\n  }\n}\n\n/**\n * Returns the first and last tabbable elements inside a container.\n */\nfunction getTabbableEdges(container: HTMLElement) {\n  const candidates = getTabbableCandidates(container);\n  const first = findVisible(candidates, container);\n  const last = findVisible(candidates.reverse(), container);\n  return [first, last] as const;\n}\n\n/**\n * Returns a list of potential tabbable candidates.\n *\n * NOTE: This is only a close approximation. For example it doesn't take into account cases like when\n * elements are not visible. This cannot be worked out easily by just reading a property, but rather\n * necessitate runtime knowledge (computed styles, etc). We deal with these cases separately.\n *\n * See: https://developer.mozilla.org/en-US/docs/Web/API/TreeWalker\n * Credit: https://github.com/discord/focus-layers/blob/master/src/util/wrapFocus.tsx#L1\n */\nfunction getTabbableCandidates(container: HTMLElement) {\n  const nodes: HTMLElement[] = [];\n  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {\n    acceptNode: (node: any) => {\n      const isHiddenInput = node.tagName === 'INPUT' && node.type === 'hidden';\n      if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP;\n      // `.tabIndex` is not the same as the `tabindex` attribute. It works on the\n      // runtime's understanding of tabbability, so this automatically accounts\n      // for any kind of element that could be tabbed to.\n      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n    },\n  });\n  while (walker.nextNode()) nodes.push(walker.currentNode as HTMLElement);\n  // we do not take into account the order of nodes with positive `tabIndex` as it\n  // hinders accessibility to have tab order different from visual order.\n  return nodes;\n}\n\n/**\n * Returns the first visible element in a list.\n * NOTE: Only checks visibility up to the `container`.\n */\nfunction findVisible(elements: HTMLElement[], container: HTMLElement) {\n  for (const element of elements) {\n    // we stop checking if it's hidden at the `container` level (excluding)\n    if (!isHidden(element, { upTo: container })) return element;\n  }\n}\n\nfunction isHidden(node: HTMLElement, { upTo }: { upTo?: HTMLElement }) {\n  if (getComputedStyle(node).visibility === 'hidden') return true;\n  while (node) {\n    // we stop at `upTo` (excluding it)\n    if (upTo !== undefined && node === upTo) return false;\n    if (getComputedStyle(node).display === 'none') return true;\n    node = node.parentElement as HTMLElement;\n  }\n  return false;\n}\n\nfunction isSelectableInput(element: any): element is FocusableTarget & { select: () => void } {\n  return element instanceof HTMLInputElement && 'select' in element;\n}\n\nfunction focus(element?: FocusableTarget | null, { select = false } = {}) {\n  // only focus if that element is focusable\n  if (element && element.focus) {\n    const previouslyFocusedElement = document.activeElement;\n    // NOTE: we prevent scrolling on focus, to minimize jarring transitions for users\n    element.focus({ preventScroll: true });\n    // only select if its not the same element, it supports selection and we need to select\n    if (element !== previouslyFocusedElement && isSelectableInput(element) && select)\n      element.select();\n  }\n}\n\n/* -------------------------------------------------------------------------------------------------\n * FocusScope stack\n * -----------------------------------------------------------------------------------------------*/\n\ntype FocusScopeAPI = { paused: boolean; pause(): void; resume(): void };\nconst focusScopesStack = createFocusScopesStack();\n\nfunction createFocusScopesStack() {\n  /** A stack of focus scopes, with the active one at the top */\n  let stack: FocusScopeAPI[] = [];\n\n  return {\n    add(focusScope: FocusScopeAPI) {\n      // pause the currently active focus scope (at the top of the stack)\n      const activeFocusScope = stack[0];\n      if (focusScope !== activeFocusScope) {\n        activeFocusScope?.pause();\n      }\n      // remove in case it already exists (because we'll re-add it at the top of the stack)\n      stack = arrayRemove(stack, focusScope);\n      stack.unshift(focusScope);\n    },\n\n    remove(focusScope: FocusScopeAPI) {\n      stack = arrayRemove(stack, focusScope);\n      stack[0]?.resume();\n    },\n  };\n}\n\nfunction arrayRemove<T>(array: T[], item: T) {\n  const updatedArray = [...array];\n  const index = updatedArray.indexOf(item);\n  if (index !== -1) {\n    updatedArray.splice(index, 1);\n  }\n  return updatedArray;\n}\n\nfunction removeLinks(items: HTMLElement[]) {\n  return items.filter((item) => item.tagName !== 'A');\n}\n\nconst Root = FocusScope;\n\nexport {\n  FocusScope,\n  //\n  Root,\n};\nexport type { FocusScopeProps };\n"]},"metadata":{},"sourceType":"module"}