{"ast":null,"code":"import { __assign, __awaiter, __generator, __rest } from \"tslib\";\nimport { SignatureV4 } from \"@aws-sdk/signature-v4\";\nimport { SHA256_HEADER, UNSIGNED_PAYLOAD } from \"./constants\";\n\nvar S3RequestPresigner =\n/** @class */\nfunction () {\n  function S3RequestPresigner(options) {\n    var resolvedOptions = __assign({\n      // Allow `signingName` because we want to support usecase of supply client's resolved config\n      // directly. Where service equals signingName.\n      service: options.signingName || options.service || \"s3\",\n      uriEscapePath: options.uriEscapePath || false\n    }, options);\n\n    this.signer = new SignatureV4(resolvedOptions);\n  }\n\n  S3RequestPresigner.prototype.presign = function (requestToSign, _a) {\n    if (_a === void 0) {\n      _a = {};\n    }\n\n    var _b = _a.unsignableHeaders,\n        unsignableHeaders = _b === void 0 ? new Set() : _b,\n        _c = _a.unhoistableHeaders,\n        unhoistableHeaders = _c === void 0 ? new Set() : _c,\n        options = __rest(_a, [\"unsignableHeaders\", \"unhoistableHeaders\"]);\n\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_d) {\n        unsignableHeaders.add(\"content-type\"); // S3 requires SSE headers to be signed in headers instead of query\n        // See: https://github.com/aws/aws-sdk-js-v3/issues/1576\n\n        Object.keys(requestToSign.headers).map(function (header) {\n          return header.toLowerCase();\n        }).filter(function (header) {\n          return header.startsWith(\"x-amz-server-side-encryption\");\n        }).forEach(function (header) {\n          unhoistableHeaders.add(header);\n        });\n        requestToSign.headers[SHA256_HEADER] = UNSIGNED_PAYLOAD;\n\n        if (!requestToSign.headers[\"host\"]) {\n          requestToSign.headers.host = requestToSign.hostname;\n        }\n\n        return [2\n        /*return*/\n        , this.signer.presign(requestToSign, __assign({\n          expiresIn: 900,\n          unsignableHeaders: unsignableHeaders,\n          unhoistableHeaders: unhoistableHeaders\n        }, options))];\n      });\n    });\n  };\n\n  return S3RequestPresigner;\n}();\n\nexport { S3RequestPresigner };","map":{"version":3,"mappings":"AAAA,SAASA,QAAT,EAAmBC,SAAnB,EAA8BC,WAA9B,EAA2CC,MAA3C,QAAyD,OAAzD;AACA,SAASC,WAAT,QAA4B,uBAA5B;AACA,SAASC,aAAT,EAAwBC,gBAAxB,QAAgD,aAAhD;;AACA,IAAIC,kBAAkB;AAAG;AAAe,YAAY;EAChD,SAASA,kBAAT,CAA4BC,OAA5B,EAAqC;IACjC,IAAIC,eAAe,GAAGT,QAAQ,CAAC;MAC3B;MACA;MACAU,OAAO,EAAEF,OAAO,CAACG,WAAR,IAAuBH,OAAO,CAACE,OAA/B,IAA0C,IAHxB;MAG8BE,aAAa,EAAEJ,OAAO,CAACI,aAAR,IAAyB;IAHtE,CAAD,EAGgFJ,OAHhF,CAA9B;;IAIA,KAAKK,MAAL,GAAc,IAAIT,WAAJ,CAAgBK,eAAhB,CAAd;EACH;;EACDF,kBAAkB,CAACO,SAAnB,CAA6BC,OAA7B,GAAuC,UAAUC,aAAV,EAAyBC,EAAzB,EAA6B;IAChE,IAAIA,EAAE,KAAK,KAAK,CAAhB,EAAmB;MAAEA,EAAE,GAAG,EAAL;IAAU;;IAC/B,IAAIC,EAAE,GAAGD,EAAE,CAACE,iBAAZ;IAAA,IAA+BA,iBAAiB,GAAGD,EAAE,KAAK,KAAK,CAAZ,GAAgB,IAAIE,GAAJ,EAAhB,GAA4BF,EAA/E;IAAA,IAAmFG,EAAE,GAAGJ,EAAE,CAACK,kBAA3F;IAAA,IAA+GA,kBAAkB,GAAGD,EAAE,KAAK,KAAK,CAAZ,GAAgB,IAAID,GAAJ,EAAhB,GAA4BC,EAAhK;IAAA,IAAoKb,OAAO,GAAGL,MAAM,CAACc,EAAD,EAAK,CAAC,mBAAD,EAAsB,oBAAtB,CAAL,CAApL;;IACA,OAAOhB,SAAS,CAAC,IAAD,EAAO,KAAK,CAAZ,EAAe,KAAK,CAApB,EAAuB,YAAY;MAC/C,OAAOC,WAAW,CAAC,IAAD,EAAO,UAAUqB,EAAV,EAAc;QACnCJ,iBAAiB,CAACK,GAAlB,CAAsB,cAAtB,EADmC,CAEnC;QACA;;QACAC,MAAM,CAACC,IAAP,CAAYV,aAAa,CAACW,OAA1B,EACKC,GADL,CACS,UAAUC,MAAV,EAAkB;UAAE,OAAOA,MAAM,CAACC,WAAP,EAAP;QAA8B,CAD3D,EAEKC,MAFL,CAEY,UAAUF,MAAV,EAAkB;UAAE,OAAOA,MAAM,CAACG,UAAP,CAAkB,8BAAlB,CAAP;QAA2D,CAF3F,EAGKC,OAHL,CAGa,UAAUJ,MAAV,EAAkB;UAC3BP,kBAAkB,CAACE,GAAnB,CAAuBK,MAAvB;QACH,CALD;QAMAb,aAAa,CAACW,OAAd,CAAsBtB,aAAtB,IAAuCC,gBAAvC;;QACA,IAAI,CAACU,aAAa,CAACW,OAAd,CAAsB,MAAtB,CAAL,EAAoC;UAChCX,aAAa,CAACW,OAAd,CAAsBO,IAAtB,GAA6BlB,aAAa,CAACmB,QAA3C;QACH;;QACD,OAAO,CAAC;QAAE;QAAH,EAAe,KAAKtB,MAAL,CAAYE,OAAZ,CAAoBC,aAApB,EAAmChB,QAAQ,CAAC;UAAEoC,SAAS,EAAE,GAAb;UAAkBjB,iBAAiB,EAAEA,iBAArC;UAC1DG,kBAAkB,EAAEA;QADsC,CAAD,EACfd,OADe,CAA3C,CAAf,CAAP;MAEH,CAhBiB,CAAlB;IAiBH,CAlBe,CAAhB;EAmBH,CAtBD;;EAuBA,OAAOD,kBAAP;AACH,CAhCuC,EAAxC;;AAiCA,SAASA,kBAAT","names":["SignatureV4","SHA256_HEADER","UNSIGNED_PAYLOAD","options","resolvedOptions","service","signingName","uriEscapePath","signer","S3RequestPresigner","requestToSign","_a","Set","_b","_c","unhoistableHeaders","unsignableHeaders","add","Object","keys","headers","map","header","toLowerCase","filter","startsWith","forEach","host","hostname","presign","__assign","expiresIn"],"sources":["/Users/arnavmisra/Desktop/Portfolio-main/Portfolio/node_modules/@aws-sdk/s3-request-presigner/src/presigner.ts"],"sourcesContent":["import { SignatureV4, SignatureV4CryptoInit, SignatureV4Init } from \"@aws-sdk/signature-v4\";\nimport { RequestPresigner, RequestPresigningArguments } from \"@aws-sdk/types\";\nimport { HttpRequest as IHttpRequest } from \"@aws-sdk/types\";\n\nimport { SHA256_HEADER, UNSIGNED_PAYLOAD } from \"./constants\";\n\n/**\n * PartialBy<T, K> makes properties specified in K optional in interface T\n * see: https://stackoverflow.com/questions/43159887/make-a-single-property-optional-in-typescript\n * */\ntype Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;\ntype PartialBy<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;\n\nexport type S3RequestPresignerOptions = PartialBy<\n  SignatureV4Init & SignatureV4CryptoInit,\n  \"service\" | \"uriEscapePath\"\n> & { signingName?: string };\n\nexport class S3RequestPresigner implements RequestPresigner {\n  private readonly signer: SignatureV4;\n  constructor(options: S3RequestPresignerOptions) {\n    const resolvedOptions = {\n      // Allow `signingName` because we want to support usecase of supply client's resolved config\n      // directly. Where service equals signingName.\n      service: options.signingName || options.service || \"s3\",\n      uriEscapePath: options.uriEscapePath || false,\n      ...options,\n    };\n    this.signer = new SignatureV4(resolvedOptions);\n  }\n\n  public async presign(\n    requestToSign: IHttpRequest,\n    { unsignableHeaders = new Set(), unhoistableHeaders = new Set(), ...options }: RequestPresigningArguments = {}\n  ): Promise<IHttpRequest> {\n    unsignableHeaders.add(\"content-type\");\n    // S3 requires SSE headers to be signed in headers instead of query\n    // See: https://github.com/aws/aws-sdk-js-v3/issues/1576\n    Object.keys(requestToSign.headers)\n      .map((header) => header.toLowerCase())\n      .filter((header) => header.startsWith(\"x-amz-server-side-encryption\"))\n      .forEach((header) => {\n        unhoistableHeaders.add(header);\n      });\n    requestToSign.headers[SHA256_HEADER] = UNSIGNED_PAYLOAD;\n    if (!requestToSign.headers[\"host\"]) {\n      requestToSign.headers.host = requestToSign.hostname;\n    }\n    return this.signer.presign(requestToSign, {\n      expiresIn: 900,\n      unsignableHeaders,\n      unhoistableHeaders,\n      ...options,\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"module"}