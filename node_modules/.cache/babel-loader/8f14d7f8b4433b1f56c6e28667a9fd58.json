{"ast":null,"code":"import { __read } from \"tslib\";\nvar DOMAIN_PATTERN = /^[a-z0-9][a-z0-9\\.\\-]{1,61}[a-z0-9]$/;\nvar IP_ADDRESS_PATTERN = /(\\d+\\.){3}\\d+/;\nvar DOTS_PATTERN = /\\.\\./;\nexport var DOT_PATTERN = /\\./;\nexport var S3_HOSTNAME_PATTERN = /^(.+\\.)?s3[.-]([a-z0-9-]+)\\./;\nvar S3_US_EAST_1_ALTNAME_PATTERN = /^s3(-external-1)?\\.amazonaws\\.com$/;\nvar AWS_PARTITION_SUFFIX = \"amazonaws.com\";\nexport var isBucketNameOptions = function (options) {\n  return typeof options.bucketName === \"string\";\n};\n/**\n * Get pseudo region from supplied region. For example, if supplied with `fips-us-west-2`, it returns `us-west-2`.\n * @internal\n */\n\nexport var getPseudoRegion = function (region) {\n  return isFipsRegion(region) ? region.replace(/fips-|-fips/, \"\") : region;\n};\n/**\n * Determines whether a given string is DNS compliant per the rules outlined by\n * S3. Length, capitaization, and leading dot restrictions are enforced by the\n * DOMAIN_PATTERN regular expression.\n * @internal\n *\n * @see https://docs.aws.amazon.com/AmazonS3/latest/dev/BucketRestrictions.html\n */\n\nexport var isDnsCompatibleBucketName = function (bucketName) {\n  return DOMAIN_PATTERN.test(bucketName) && !IP_ADDRESS_PATTERN.test(bucketName) && !DOTS_PATTERN.test(bucketName);\n};\n\nvar getRegionalSuffix = function (hostname) {\n  var parts = hostname.match(S3_HOSTNAME_PATTERN);\n  return [parts[2], hostname.replace(new RegExp(\"^\" + parts[0]), \"\")];\n};\n\nexport var getSuffix = function (hostname) {\n  return S3_US_EAST_1_ALTNAME_PATTERN.test(hostname) ? [\"us-east-1\", AWS_PARTITION_SUFFIX] : getRegionalSuffix(hostname);\n};\n/**\n * Infer region and hostname suffix from a complete hostname\n * @internal\n * @param hostname - Hostname\n * @returns [Region, Hostname suffix]\n */\n\nexport var getSuffixForArnEndpoint = function (hostname) {\n  return S3_US_EAST_1_ALTNAME_PATTERN.test(hostname) ? [hostname.replace(\".\" + AWS_PARTITION_SUFFIX, \"\"), AWS_PARTITION_SUFFIX] : getRegionalSuffix(hostname);\n};\nexport var validateArnEndpointOptions = function (options) {\n  if (options.pathStyleEndpoint) {\n    throw new Error(\"Path-style S3 endpoint is not supported when bucket is an ARN\");\n  }\n\n  if (options.accelerateEndpoint) {\n    throw new Error(\"Accelerate endpoint is not supported when bucket is an ARN\");\n  }\n\n  if (!options.tlsCompatible) {\n    throw new Error(\"HTTPS is required when bucket is an ARN\");\n  }\n};\nexport var validateService = function (service) {\n  if (service !== \"s3\" && service !== \"s3-outposts\") {\n    throw new Error(\"Expect 's3' or 's3-outposts' in ARN service component\");\n  }\n};\nexport var validateS3Service = function (service) {\n  if (service !== \"s3\") {\n    throw new Error(\"Expect 's3' in Accesspoint ARN service component\");\n  }\n};\nexport var validateOutpostService = function (service) {\n  if (service !== \"s3-outposts\") {\n    throw new Error(\"Expect 's3-posts' in Outpost ARN service component\");\n  }\n};\n/**\n * Validate partition inferred from ARN is the same to `options.clientPartition`.\n * @internal\n */\n\nexport var validatePartition = function (partition, options) {\n  if (partition !== options.clientPartition) {\n    throw new Error(\"Partition in ARN is incompatible, got \\\"\" + partition + \"\\\" but expected \\\"\" + options.clientPartition + \"\\\"\");\n  }\n};\n/**\n * validate region value inferred from ARN. If `options.useArnRegion` is set, it validates the region is not a FIPS\n * region. If `options.useArnRegion` is unset, it validates the region is equal to `options.clientRegion` or\n * `options.clientSigningRegion`.\n * @internal\n */\n\nexport var validateRegion = function (region, options) {\n  if (region === \"\") {\n    throw new Error(\"ARN region is empty\");\n  }\n\n  if (!options.useArnRegion && !isEqualRegions(region, options.clientRegion) && !isEqualRegions(region, options.clientSigningRegion)) {\n    throw new Error(\"Region in ARN is incompatible, got \" + region + \" but expected \" + options.clientRegion);\n  }\n\n  if (options.useArnRegion && isFipsRegion(region)) {\n    throw new Error(\"Endpoint does not support FIPS region\");\n  }\n};\n\nvar isFipsRegion = function (region) {\n  return region.startsWith(\"fips-\") || region.endsWith(\"-fips\");\n};\n\nvar isEqualRegions = function (regionA, regionB) {\n  return regionA === regionB || getPseudoRegion(regionA) === regionB || regionA === getPseudoRegion(regionB);\n};\n/**\n * Validate an account ID\n * @internal\n */\n\n\nexport var validateAccountId = function (accountId) {\n  if (!/[0-9]{12}/.exec(accountId)) {\n    throw new Error(\"Access point ARN accountID does not match regex '[0-9]{12}'\");\n  }\n};\n/**\n * Validate a host label according to https://tools.ietf.org/html/rfc3986#section-3.2.2\n * @internal\n */\n\nexport var validateDNSHostLabel = function (label, options) {\n  if (options === void 0) {\n    options = {\n      tlsCompatible: true\n    };\n  } // reference: https://tools.ietf.org/html/rfc3986#section-3.2.2\n\n\n  if (label.length >= 64 || !/^[a-z0-9][a-z0-9.-]+[a-z0-9]$/.test(label) || /(\\d+\\.){3}\\d+/.test(label) || /[.-]{2}/.test(label) || (options === null || options === void 0 ? void 0 : options.tlsCompatible) && DOT_PATTERN.test(label)) {\n    throw new Error(\"Invalid DNS label \" + label);\n  }\n};\n/**\n * Validate and parse an Access Point ARN or Outposts ARN\n * @internal\n *\n * @param resource - The resource section of an ARN\n * @returns Access Point Name and optional Outpost ID.\n */\n\nexport var getArnResources = function (resource) {\n  var delimiter = resource.includes(\":\") ? \":\" : \"/\";\n\n  var _a = __read(resource.split(delimiter)),\n      resourceType = _a[0],\n      rest = _a.slice(1);\n\n  if (resourceType === \"accesspoint\") {\n    // Parse accesspoint ARN\n    if (rest.length !== 1 || rest[0] === \"\") {\n      throw new Error(\"Access Point ARN should have one resource accesspoint\" + delimiter + \"{accesspointname}\");\n    }\n\n    return {\n      accesspointName: rest[0]\n    };\n  } else if (resourceType === \"outpost\") {\n    // Parse outpost ARN\n    if (!rest[0] || rest[1] !== \"accesspoint\" || !rest[2] || rest.length !== 3) {\n      throw new Error(\"Outpost ARN should have resource outpost\" + delimiter + \"{outpostId}\" + delimiter + \"accesspoint\" + delimiter + \"{accesspointName}\");\n    }\n\n    var _b = __read(rest, 3),\n        outpostId = _b[0],\n        _ = _b[1],\n        accesspointName = _b[2];\n\n    return {\n      outpostId: outpostId,\n      accesspointName: accesspointName\n    };\n  } else {\n    throw new Error(\"ARN resource should begin with 'accesspoint\" + delimiter + \"' or 'outpost\" + delimiter + \"'\");\n  }\n};\n/**\n * Throw if dual stack configuration is set to true.\n * @internal\n */\n\nexport var validateNoDualstack = function (dualstackEndpoint) {\n  if (dualstackEndpoint) throw new Error(\"Dualstack endpoint is not supported with Outpost\");\n};\n/**\n * Validate region is not appended or prepended with a `fips-`\n * @internal\n */\n\nexport var validateNoFIPS = function (region) {\n  if (isFipsRegion(region !== null && region !== void 0 ? region : \"\")) throw new Error(\"FIPS region is not supported with Outpost, got \" + region);\n};","map":{"version":3,"mappings":"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","names":["DOMAIN_PATTERN","IP_ADDRESS_PATTERN","DOTS_PATTERN","DOT_PATTERN","S3_HOSTNAME_PATTERN","S3_US_EAST_1_ALTNAME_PATTERN","AWS_PARTITION_SUFFIX","isBucketNameOptions","options","bucketName","getPseudoRegion","region","isFipsRegion","replace","isDnsCompatibleBucketName","test","getRegionalSuffix","hostname","parts","match","RegExp","getSuffix","getSuffixForArnEndpoint","validateArnEndpointOptions","pathStyleEndpoint","Error","accelerateEndpoint","tlsCompatible","validateService","service","validateS3Service","validateOutpostService","validatePartition","partition","clientPartition","validateRegion","useArnRegion","isEqualRegions","clientRegion","clientSigningRegion","startsWith","endsWith","regionA","regionB","validateAccountId","accountId","exec","validateDNSHostLabel","label","length","getArnResources","resource","delimiter","includes","split","resourceType","rest","accesspointName","outpostId","_","validateNoDualstack","dualstackEndpoint","validateNoFIPS"],"sources":["/Users/arnavmisra/Desktop/Portfolio-main/Portfolio/node_modules/@aws-sdk/middleware-bucket-endpoint/src/bucketHostnameUtils.ts"],"sourcesContent":["import { ARN } from \"@aws-sdk/util-arn-parser\";\n\nconst DOMAIN_PATTERN = /^[a-z0-9][a-z0-9\\.\\-]{1,61}[a-z0-9]$/;\nconst IP_ADDRESS_PATTERN = /(\\d+\\.){3}\\d+/;\nconst DOTS_PATTERN = /\\.\\./;\nexport const DOT_PATTERN = /\\./;\nexport const S3_HOSTNAME_PATTERN = /^(.+\\.)?s3[.-]([a-z0-9-]+)\\./;\nconst S3_US_EAST_1_ALTNAME_PATTERN = /^s3(-external-1)?\\.amazonaws\\.com$/;\nconst AWS_PARTITION_SUFFIX = \"amazonaws.com\";\n\nexport interface AccessPointArn extends ARN {\n  accessPointName: string;\n}\n\nexport interface BucketHostnameParams {\n  isCustomEndpoint: boolean;\n  baseHostname: string;\n  bucketName: string;\n  clientRegion: string;\n  accelerateEndpoint?: boolean;\n  dualstackEndpoint?: boolean;\n  pathStyleEndpoint?: boolean;\n  tlsCompatible?: boolean;\n}\n\nexport interface ArnHostnameParams extends Omit<BucketHostnameParams, \"bucketName\"> {\n  bucketName: ARN;\n  clientSigningRegion?: string;\n  clientPartition?: string;\n  useArnRegion?: boolean;\n}\n\nexport const isBucketNameOptions = (\n  options: BucketHostnameParams | ArnHostnameParams\n): options is BucketHostnameParams => typeof options.bucketName === \"string\";\n\n/**\n * Get pseudo region from supplied region. For example, if supplied with `fips-us-west-2`, it returns `us-west-2`.\n * @internal\n */\nexport const getPseudoRegion = (region: string) => (isFipsRegion(region) ? region.replace(/fips-|-fips/, \"\") : region);\n\n/**\n * Determines whether a given string is DNS compliant per the rules outlined by\n * S3. Length, capitaization, and leading dot restrictions are enforced by the\n * DOMAIN_PATTERN regular expression.\n * @internal\n *\n * @see https://docs.aws.amazon.com/AmazonS3/latest/dev/BucketRestrictions.html\n */\nexport const isDnsCompatibleBucketName = (bucketName: string): boolean =>\n  DOMAIN_PATTERN.test(bucketName) && !IP_ADDRESS_PATTERN.test(bucketName) && !DOTS_PATTERN.test(bucketName);\n\nconst getRegionalSuffix = (hostname: string): [string, string] => {\n  const parts = hostname.match(S3_HOSTNAME_PATTERN)!;\n  return [parts[2], hostname.replace(new RegExp(`^${parts[0]}`), \"\")];\n};\n\nexport const getSuffix = (hostname: string): [string, string] =>\n  S3_US_EAST_1_ALTNAME_PATTERN.test(hostname) ? [\"us-east-1\", AWS_PARTITION_SUFFIX] : getRegionalSuffix(hostname);\n\n/**\n * Infer region and hostname suffix from a complete hostname\n * @internal\n * @param hostname - Hostname\n * @returns [Region, Hostname suffix]\n */\nexport const getSuffixForArnEndpoint = (hostname: string): [string, string] =>\n  S3_US_EAST_1_ALTNAME_PATTERN.test(hostname)\n    ? [hostname.replace(`.${AWS_PARTITION_SUFFIX}`, \"\"), AWS_PARTITION_SUFFIX]\n    : getRegionalSuffix(hostname);\n\nexport const validateArnEndpointOptions = (options: {\n  accelerateEndpoint?: boolean;\n  tlsCompatible?: boolean;\n  pathStyleEndpoint?: boolean;\n}) => {\n  if (options.pathStyleEndpoint) {\n    throw new Error(\"Path-style S3 endpoint is not supported when bucket is an ARN\");\n  }\n  if (options.accelerateEndpoint) {\n    throw new Error(\"Accelerate endpoint is not supported when bucket is an ARN\");\n  }\n  if (!options.tlsCompatible) {\n    throw new Error(\"HTTPS is required when bucket is an ARN\");\n  }\n};\n\nexport const validateService = (service: string) => {\n  if (service !== \"s3\" && service !== \"s3-outposts\") {\n    throw new Error(\"Expect 's3' or 's3-outposts' in ARN service component\");\n  }\n};\n\nexport const validateS3Service = (service: string) => {\n  if (service !== \"s3\") {\n    throw new Error(\"Expect 's3' in Accesspoint ARN service component\");\n  }\n};\n\nexport const validateOutpostService = (service: string) => {\n  if (service !== \"s3-outposts\") {\n    throw new Error(\"Expect 's3-posts' in Outpost ARN service component\");\n  }\n};\n\n/**\n * Validate partition inferred from ARN is the same to `options.clientPartition`.\n * @internal\n */\nexport const validatePartition = (partition: string, options: { clientPartition: string }) => {\n  if (partition !== options.clientPartition) {\n    throw new Error(`Partition in ARN is incompatible, got \"${partition}\" but expected \"${options.clientPartition}\"`);\n  }\n};\n\n/**\n * validate region value inferred from ARN. If `options.useArnRegion` is set, it validates the region is not a FIPS\n * region. If `options.useArnRegion` is unset, it validates the region is equal to `options.clientRegion` or\n * `options.clientSigningRegion`.\n * @internal\n */\nexport const validateRegion = (\n  region: string,\n  options: {\n    useArnRegion?: boolean;\n    clientRegion: string;\n    clientSigningRegion: string;\n  }\n) => {\n  if (region === \"\") {\n    throw new Error(\"ARN region is empty\");\n  }\n  if (\n    !options.useArnRegion &&\n    !isEqualRegions(region, options.clientRegion) &&\n    !isEqualRegions(region, options.clientSigningRegion)\n  ) {\n    throw new Error(`Region in ARN is incompatible, got ${region} but expected ${options.clientRegion}`);\n  }\n  if (options.useArnRegion && isFipsRegion(region)) {\n    throw new Error(\"Endpoint does not support FIPS region\");\n  }\n};\n\nconst isFipsRegion = (region: string) => region.startsWith(\"fips-\") || region.endsWith(\"-fips\");\n\nconst isEqualRegions = (regionA: string, regionB: string) =>\n  regionA === regionB || getPseudoRegion(regionA) === regionB || regionA === getPseudoRegion(regionB);\n\n/**\n * Validate an account ID\n * @internal\n */\nexport const validateAccountId = (accountId: string) => {\n  if (!/[0-9]{12}/.exec(accountId)) {\n    throw new Error(\"Access point ARN accountID does not match regex '[0-9]{12}'\");\n  }\n};\n\n/**\n * Validate a host label according to https://tools.ietf.org/html/rfc3986#section-3.2.2\n * @internal\n */\nexport const validateDNSHostLabel = (label: string, options: { tlsCompatible?: boolean } = { tlsCompatible: true }) => {\n  // reference: https://tools.ietf.org/html/rfc3986#section-3.2.2\n  if (\n    label.length >= 64 ||\n    !/^[a-z0-9][a-z0-9.-]+[a-z0-9]$/.test(label) ||\n    /(\\d+\\.){3}\\d+/.test(label) ||\n    /[.-]{2}/.test(label) ||\n    (options?.tlsCompatible && DOT_PATTERN.test(label))\n  ) {\n    throw new Error(`Invalid DNS label ${label}`);\n  }\n};\n\n/**\n * Validate and parse an Access Point ARN or Outposts ARN\n * @internal\n *\n * @param resource - The resource section of an ARN\n * @returns Access Point Name and optional Outpost ID.\n */\nexport const getArnResources = (\n  resource: string\n): {\n  accesspointName: string;\n  outpostId?: string;\n} => {\n  const delimiter = resource.includes(\":\") ? \":\" : \"/\";\n  const [resourceType, ...rest] = resource.split(delimiter);\n  if (resourceType === \"accesspoint\") {\n    // Parse accesspoint ARN\n    if (rest.length !== 1 || rest[0] === \"\") {\n      throw new Error(`Access Point ARN should have one resource accesspoint${delimiter}{accesspointname}`);\n    }\n    return { accesspointName: rest[0] };\n  } else if (resourceType === \"outpost\") {\n    // Parse outpost ARN\n    if (!rest[0] || rest[1] !== \"accesspoint\" || !rest[2] || rest.length !== 3) {\n      throw new Error(\n        `Outpost ARN should have resource outpost${delimiter}{outpostId}${delimiter}accesspoint${delimiter}{accesspointName}`\n      );\n    }\n    const [outpostId, _, accesspointName] = rest;\n    return { outpostId, accesspointName };\n  } else {\n    throw new Error(`ARN resource should begin with 'accesspoint${delimiter}' or 'outpost${delimiter}'`);\n  }\n};\n\n/**\n * Throw if dual stack configuration is set to true.\n * @internal\n */\nexport const validateNoDualstack = (dualstackEndpoint: boolean) => {\n  if (dualstackEndpoint) throw new Error(\"Dualstack endpoint is not supported with Outpost\");\n};\n\n/**\n * Validate region is not appended or prepended with a `fips-`\n * @internal\n */\nexport const validateNoFIPS = (region: string) => {\n  if (isFipsRegion(region ?? \"\")) throw new Error(`FIPS region is not supported with Outpost, got ${region}`);\n};\n"]},"metadata":{},"sourceType":"module"}