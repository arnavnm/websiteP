{"ast":null,"code":"export default function (e, n) {\n  return n = n || {}, new Promise(function (t, r) {\n    var s = new XMLHttpRequest(),\n        o = [],\n        u = [],\n        i = {},\n        a = function () {\n      return {\n        ok: 2 == (s.status / 100 | 0),\n        statusText: s.statusText,\n        status: s.status,\n        url: s.responseURL,\n        text: function () {\n          return Promise.resolve(s.responseText);\n        },\n        json: function () {\n          return Promise.resolve(s.responseText).then(JSON.parse);\n        },\n        blob: function () {\n          return Promise.resolve(new Blob([s.response]));\n        },\n        clone: a,\n        headers: {\n          keys: function () {\n            return o;\n          },\n          entries: function () {\n            return u;\n          },\n          get: function (e) {\n            return i[e.toLowerCase()];\n          },\n          has: function (e) {\n            return e.toLowerCase() in i;\n          }\n        }\n      };\n    };\n\n    for (var l in s.open(n.method || \"get\", e, !0), s.onload = function () {\n      s.getAllResponseHeaders().replace(/^(.*?):[^\\S\\n]*([\\s\\S]*?)$/gm, function (e, n, t) {\n        o.push(n = n.toLowerCase()), u.push([n, t]), i[n] = i[n] ? i[n] + \",\" + t : t;\n      }), t(a());\n    }, s.onerror = r, s.withCredentials = \"include\" == n.credentials, n.headers) s.setRequestHeader(l, n.headers[l]);\n\n    s.send(n.body || null);\n  });\n}","map":{"version":3,"mappings":"AAAA,eAAe,UAASA,CAAT,EAAWC,CAAX,EAAa;EAAC,OAAOA,CAAC,GAACA,CAAC,IAAE,EAAL,EAAQ,IAAIC,OAAJ,CAAY,UAASC,CAAT,EAAWC,CAAX,EAAa;IAAC,IAAIC,CAAC,GAAC,IAAIC,cAAJ,EAAN;IAAA,IAAyBC,CAAC,GAAC,EAA3B;IAAA,IAA8BC,CAAC,GAAC,EAAhC;IAAA,IAAmCC,CAAC,GAAC,EAArC;IAAA,IAAwCC,CAAC,GAAC,YAAU;MAAC,OAAM;QAACC,EAAE,EAAC,MAAIN,CAAC,CAACO,MAAF,GAAS,GAAT,GAAa,CAAjB,CAAJ;QAAwBC,UAAU,EAACR,CAAC,CAACQ,UAArC;QAAgDD,MAAM,EAACP,CAAC,CAACO,MAAzD;QAAgEE,GAAG,EAACT,CAAC,CAACU,WAAtE;QAAkFC,IAAI,EAAC,YAAU;UAAC,OAAOd,OAAO,CAACe,OAAR,CAAgBZ,CAAC,CAACa,YAAlB,CAAP;QAAuC,CAAzI;QAA0IC,IAAI,EAAC,YAAU;UAAC,OAAOjB,OAAO,CAACe,OAAR,CAAgBZ,CAAC,CAACa,YAAlB,EAAgCE,IAAhC,CAAqCC,IAAI,CAACC,KAA1C,CAAP;QAAwD,CAAlN;QAAmNC,IAAI,EAAC,YAAU;UAAC,OAAOrB,OAAO,CAACe,OAAR,CAAgB,IAAIO,IAAJ,CAAS,CAACnB,CAAC,CAACoB,QAAH,CAAT,CAAhB,CAAP;QAA+C,CAAlR;QAAmRC,KAAK,EAAChB,CAAzR;QAA2RiB,OAAO,EAAC;UAACC,IAAI,EAAC,YAAU;YAAC,OAAOrB,CAAP;UAAS,CAA1B;UAA2BsB,OAAO,EAAC,YAAU;YAAC,OAAOrB,CAAP;UAAS,CAAvD;UAAwDsB,GAAG,EAAC,UAAS9B,CAAT,EAAW;YAAC,OAAOS,CAAC,CAACT,CAAC,CAAC+B,WAAF,EAAD,CAAR;UAA0B,CAAlG;UAAmGC,GAAG,EAAC,UAAShC,CAAT,EAAW;YAAC,OAAOA,CAAC,CAAC+B,WAAF,MAAkBtB,CAAzB;UAA2B;QAA9I;MAAnS,CAAN;IAA0b,CAA/e;;IAAgf,KAAI,IAAIwB,CAAR,IAAa5B,CAAC,CAAC6B,IAAF,CAAOjC,CAAC,CAACkC,MAAF,IAAU,KAAjB,EAAuBnC,CAAvB,EAAyB,CAAC,CAA1B,GAA6BK,CAAC,CAAC+B,MAAF,GAAS,YAAU;MAAC/B,CAAC,CAACgC,qBAAF,GAA0BC,OAA1B,CAAkC,8BAAlC,EAAiE,UAAStC,CAAT,EAAWC,CAAX,EAAaE,CAAb,EAAe;QAACI,CAAC,CAACgC,IAAF,CAAOtC,CAAC,GAACA,CAAC,CAAC8B,WAAF,EAAT,GAA0BvB,CAAC,CAAC+B,IAAF,CAAO,CAACtC,CAAD,EAAGE,CAAH,CAAP,CAA1B,EAAwCM,CAAC,CAACR,CAAD,CAAD,GAAKQ,CAAC,CAACR,CAAD,CAAD,GAAKQ,CAAC,CAACR,CAAD,CAAD,GAAK,GAAL,GAASE,CAAd,GAAgBA,CAA7D;MAA+D,CAAhJ,GAAkJA,CAAC,CAACO,CAAC,EAAF,CAAnJ;IAAyJ,CAA1M,EAA2ML,CAAC,CAACmC,OAAF,GAAUpC,CAArN,EAAuNC,CAAC,CAACoC,eAAF,GAAkB,aAAWxC,CAAC,CAACyC,WAAtP,EAAkQzC,CAAC,CAAC0B,OAAjR,EAAyRtB,CAAC,CAACsC,gBAAF,CAAmBV,CAAnB,EAAqBhC,CAAC,CAAC0B,OAAF,CAAUM,CAAV,CAArB;;IAAmC5B,CAAC,CAACuC,IAAF,CAAO3C,CAAC,CAAC4C,IAAF,IAAQ,IAAf;EAAqB,CAA31B,CAAf;AAA42B","names":["url","options","Promise","resolve","reject","request","XMLHttpRequest","keys","all","headers","response","ok","status","statusText","responseURL","text","responseText","json","then","JSON","parse","blob","Blob","clone","entries","get","n","toLowerCase","has","const","i","open","method","onload","getAllResponseHeaders","replace","m","key","value","push","onerror","withCredentials","credentials","setRequestHeader","send","body"],"sources":["/Users/arnavmisra/Desktop/Portfolio-main/node_modules/unfetch/src/index.mjs"],"sourcesContent":["export default function(url, options) {\n\toptions = options || {};\n\treturn new Promise( (resolve, reject) => {\n\t\tconst request = new XMLHttpRequest();\n\t\tconst keys = [];\n\t\tconst all = [];\n\t\tconst headers = {};\n\n\t\tconst response = () => ({\n\t\t\tok: (request.status/100|0) == 2,\t\t// 200-299\n\t\t\tstatusText: request.statusText,\n\t\t\tstatus: request.status,\n\t\t\turl: request.responseURL,\n\t\t\ttext: () => Promise.resolve(request.responseText),\n\t\t\tjson: () => Promise.resolve(request.responseText).then(JSON.parse),\n\t\t\tblob: () => Promise.resolve(new Blob([request.response])),\n\t\t\tclone: response,\n\t\t\theaders: {\n\t\t\t\tkeys: () => keys,\n\t\t\t\tentries: () => all,\n\t\t\t\tget: n => headers[n.toLowerCase()],\n\t\t\t\thas: n => n.toLowerCase() in headers\n\t\t\t}\n\t\t});\n\n\t\trequest.open(options.method || 'get', url, true);\n\n\t\trequest.onload = () => {\n\t\t\trequest.getAllResponseHeaders().replace(/^(.*?):[^\\S\\n]*([\\s\\S]*?)$/gm, (m, key, value) => {\n\t\t\t\tkeys.push(key = key.toLowerCase());\n\t\t\t\tall.push([key, value]);\n\t\t\t\theaders[key] = headers[key] ? `${headers[key]},${value}` : value;\n\t\t\t});\n\t\t\tresolve(response());\n\t\t};\n\n\t\trequest.onerror = reject;\n\n\t\trequest.withCredentials = options.credentials=='include';\n\n\t\tfor (const i in options.headers) {\n\t\t\trequest.setRequestHeader(i, options.headers[i]);\n\t\t}\n\n\t\trequest.send(options.body || null);\n\t});\n}\n"]},"metadata":{},"sourceType":"module"}