{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.RawSha256 = void 0;\n\nvar constants_1 = require(\"./constants\");\n/**\n * @internal\n */\n\n\nvar RawSha256 =\n/** @class */\nfunction () {\n  function RawSha256() {\n    this.state = Int32Array.from(constants_1.INIT);\n    this.temp = new Int32Array(64);\n    this.buffer = new Uint8Array(64);\n    this.bufferLength = 0;\n    this.bytesHashed = 0;\n    /**\n     * @internal\n     */\n\n    this.finished = false;\n  }\n\n  RawSha256.prototype.update = function (data) {\n    if (this.finished) {\n      throw new Error(\"Attempted to update an already finished hash.\");\n    }\n\n    var position = 0;\n    var byteLength = data.byteLength;\n    this.bytesHashed += byteLength;\n\n    if (this.bytesHashed * 8 > constants_1.MAX_HASHABLE_LENGTH) {\n      throw new Error(\"Cannot hash more than 2^53 - 1 bits\");\n    }\n\n    while (byteLength > 0) {\n      this.buffer[this.bufferLength++] = data[position++];\n      byteLength--;\n\n      if (this.bufferLength === constants_1.BLOCK_SIZE) {\n        this.hashBuffer();\n        this.bufferLength = 0;\n      }\n    }\n  };\n\n  RawSha256.prototype.digest = function () {\n    if (!this.finished) {\n      var bitsHashed = this.bytesHashed * 8;\n      var bufferView = new DataView(this.buffer.buffer, this.buffer.byteOffset, this.buffer.byteLength);\n      var undecoratedLength = this.bufferLength;\n      bufferView.setUint8(this.bufferLength++, 0x80); // Ensure the final block has enough room for the hashed length\n\n      if (undecoratedLength % constants_1.BLOCK_SIZE >= constants_1.BLOCK_SIZE - 8) {\n        for (var i = this.bufferLength; i < constants_1.BLOCK_SIZE; i++) {\n          bufferView.setUint8(i, 0);\n        }\n\n        this.hashBuffer();\n        this.bufferLength = 0;\n      }\n\n      for (var i = this.bufferLength; i < constants_1.BLOCK_SIZE - 8; i++) {\n        bufferView.setUint8(i, 0);\n      }\n\n      bufferView.setUint32(constants_1.BLOCK_SIZE - 8, Math.floor(bitsHashed / 0x100000000), true);\n      bufferView.setUint32(constants_1.BLOCK_SIZE - 4, bitsHashed);\n      this.hashBuffer();\n      this.finished = true;\n    } // The value in state is little-endian rather than big-endian, so flip\n    // each word into a new Uint8Array\n\n\n    var out = new Uint8Array(constants_1.DIGEST_LENGTH);\n\n    for (var i = 0; i < 8; i++) {\n      out[i * 4] = this.state[i] >>> 24 & 0xff;\n      out[i * 4 + 1] = this.state[i] >>> 16 & 0xff;\n      out[i * 4 + 2] = this.state[i] >>> 8 & 0xff;\n      out[i * 4 + 3] = this.state[i] >>> 0 & 0xff;\n    }\n\n    return out;\n  };\n\n  RawSha256.prototype.hashBuffer = function () {\n    var _a = this,\n        buffer = _a.buffer,\n        state = _a.state;\n\n    var state0 = state[0],\n        state1 = state[1],\n        state2 = state[2],\n        state3 = state[3],\n        state4 = state[4],\n        state5 = state[5],\n        state6 = state[6],\n        state7 = state[7];\n\n    for (var i = 0; i < constants_1.BLOCK_SIZE; i++) {\n      if (i < 16) {\n        this.temp[i] = (buffer[i * 4] & 0xff) << 24 | (buffer[i * 4 + 1] & 0xff) << 16 | (buffer[i * 4 + 2] & 0xff) << 8 | buffer[i * 4 + 3] & 0xff;\n      } else {\n        var u = this.temp[i - 2];\n        var t1_1 = (u >>> 17 | u << 15) ^ (u >>> 19 | u << 13) ^ u >>> 10;\n        u = this.temp[i - 15];\n        var t2_1 = (u >>> 7 | u << 25) ^ (u >>> 18 | u << 14) ^ u >>> 3;\n        this.temp[i] = (t1_1 + this.temp[i - 7] | 0) + (t2_1 + this.temp[i - 16] | 0);\n      }\n\n      var t1 = (((state4 >>> 6 | state4 << 26) ^ (state4 >>> 11 | state4 << 21) ^ (state4 >>> 25 | state4 << 7)) + (state4 & state5 ^ ~state4 & state6) | 0) + (state7 + (constants_1.KEY[i] + this.temp[i] | 0) | 0) | 0;\n      var t2 = ((state0 >>> 2 | state0 << 30) ^ (state0 >>> 13 | state0 << 19) ^ (state0 >>> 22 | state0 << 10)) + (state0 & state1 ^ state0 & state2 ^ state1 & state2) | 0;\n      state7 = state6;\n      state6 = state5;\n      state5 = state4;\n      state4 = state3 + t1 | 0;\n      state3 = state2;\n      state2 = state1;\n      state1 = state0;\n      state0 = t1 + t2 | 0;\n    }\n\n    state[0] += state0;\n    state[1] += state1;\n    state[2] += state2;\n    state[3] += state3;\n    state[4] += state4;\n    state[5] += state5;\n    state[6] += state6;\n    state[7] += state7;\n  };\n\n  return RawSha256;\n}();\n\nexports.RawSha256 = RawSha256;","map":{"version":3,"mappings":"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","names":["Int32Array","from","constants_1","Uint8Array","RawSha256","data","finished","Error","position","bytesHashed","byteLength","buffer","bufferLength","hashBuffer","bitsHashed","bufferView","DataView","byteOffset","undecoratedLength","setUint8","i","setUint32","Math","floor","out","state","state0","state1","state2","state3","state4","state5","state6","state7","temp","u","t1_1","t2_1","t1","t2","exports"],"sources":["/Users/arnavmisra/Desktop/Portfolio-main/Portfolio/node_modules/@aws-crypto/sha256-browser/node_modules/@aws-crypto/sha256-js/src/RawSha256.ts"],"sourcesContent":["import {\n  BLOCK_SIZE,\n  DIGEST_LENGTH,\n  INIT,\n  KEY,\n  MAX_HASHABLE_LENGTH\n} from \"./constants\";\n\n/**\n * @internal\n */\nexport class RawSha256 {\n  private state: Int32Array = Int32Array.from(INIT);\n  private temp: Int32Array = new Int32Array(64);\n  private buffer: Uint8Array = new Uint8Array(64);\n  private bufferLength: number = 0;\n  private bytesHashed: number = 0;\n\n  /**\n   * @internal\n   */\n  finished: boolean = false;\n\n  update(data: Uint8Array): void {\n    if (this.finished) {\n      throw new Error(\"Attempted to update an already finished hash.\");\n    }\n\n    let position = 0;\n    let { byteLength } = data;\n    this.bytesHashed += byteLength;\n\n    if (this.bytesHashed * 8 > MAX_HASHABLE_LENGTH) {\n      throw new Error(\"Cannot hash more than 2^53 - 1 bits\");\n    }\n\n    while (byteLength > 0) {\n      this.buffer[this.bufferLength++] = data[position++];\n      byteLength--;\n\n      if (this.bufferLength === BLOCK_SIZE) {\n        this.hashBuffer();\n        this.bufferLength = 0;\n      }\n    }\n  }\n\n  digest(): Uint8Array {\n    if (!this.finished) {\n      const bitsHashed = this.bytesHashed * 8;\n      const bufferView = new DataView(\n        this.buffer.buffer,\n        this.buffer.byteOffset,\n        this.buffer.byteLength\n      );\n\n      const undecoratedLength = this.bufferLength;\n      bufferView.setUint8(this.bufferLength++, 0x80);\n\n      // Ensure the final block has enough room for the hashed length\n      if (undecoratedLength % BLOCK_SIZE >= BLOCK_SIZE - 8) {\n        for (let i = this.bufferLength; i < BLOCK_SIZE; i++) {\n          bufferView.setUint8(i, 0);\n        }\n        this.hashBuffer();\n        this.bufferLength = 0;\n      }\n\n      for (let i = this.bufferLength; i < BLOCK_SIZE - 8; i++) {\n        bufferView.setUint8(i, 0);\n      }\n      bufferView.setUint32(\n        BLOCK_SIZE - 8,\n        Math.floor(bitsHashed / 0x100000000),\n        true\n      );\n      bufferView.setUint32(BLOCK_SIZE - 4, bitsHashed);\n\n      this.hashBuffer();\n\n      this.finished = true;\n    }\n\n    // The value in state is little-endian rather than big-endian, so flip\n    // each word into a new Uint8Array\n    const out = new Uint8Array(DIGEST_LENGTH);\n    for (let i = 0; i < 8; i++) {\n      out[i * 4] = (this.state[i] >>> 24) & 0xff;\n      out[i * 4 + 1] = (this.state[i] >>> 16) & 0xff;\n      out[i * 4 + 2] = (this.state[i] >>> 8) & 0xff;\n      out[i * 4 + 3] = (this.state[i] >>> 0) & 0xff;\n    }\n\n    return out;\n  }\n\n  private hashBuffer(): void {\n    const { buffer, state } = this;\n\n    let state0 = state[0],\n      state1 = state[1],\n      state2 = state[2],\n      state3 = state[3],\n      state4 = state[4],\n      state5 = state[5],\n      state6 = state[6],\n      state7 = state[7];\n\n    for (let i = 0; i < BLOCK_SIZE; i++) {\n      if (i < 16) {\n        this.temp[i] =\n          ((buffer[i * 4] & 0xff) << 24) |\n          ((buffer[i * 4 + 1] & 0xff) << 16) |\n          ((buffer[i * 4 + 2] & 0xff) << 8) |\n          (buffer[i * 4 + 3] & 0xff);\n      } else {\n        let u = this.temp[i - 2];\n        const t1 =\n          ((u >>> 17) | (u << 15)) ^ ((u >>> 19) | (u << 13)) ^ (u >>> 10);\n\n        u = this.temp[i - 15];\n        const t2 =\n          ((u >>> 7) | (u << 25)) ^ ((u >>> 18) | (u << 14)) ^ (u >>> 3);\n\n        this.temp[i] =\n          ((t1 + this.temp[i - 7]) | 0) + ((t2 + this.temp[i - 16]) | 0);\n      }\n\n      const t1 =\n        ((((((state4 >>> 6) | (state4 << 26)) ^\n          ((state4 >>> 11) | (state4 << 21)) ^\n          ((state4 >>> 25) | (state4 << 7))) +\n          ((state4 & state5) ^ (~state4 & state6))) |\n          0) +\n          ((state7 + ((KEY[i] + this.temp[i]) | 0)) | 0)) |\n        0;\n\n      const t2 =\n        ((((state0 >>> 2) | (state0 << 30)) ^\n          ((state0 >>> 13) | (state0 << 19)) ^\n          ((state0 >>> 22) | (state0 << 10))) +\n          ((state0 & state1) ^ (state0 & state2) ^ (state1 & state2))) |\n        0;\n\n      state7 = state6;\n      state6 = state5;\n      state5 = state4;\n      state4 = (state3 + t1) | 0;\n      state3 = state2;\n      state2 = state1;\n      state1 = state0;\n      state0 = (t1 + t2) | 0;\n    }\n\n    state[0] += state0;\n    state[1] += state1;\n    state[2] += state2;\n    state[3] += state3;\n    state[4] += state4;\n    state[5] += state5;\n    state[6] += state6;\n    state[7] += state7;\n  }\n}\n"]},"metadata":{},"sourceType":"script"}