{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/arnavmisra/Desktop/Portfolio-main/Portfolio/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\n\n/** These methods may break the react binding if called directly */\nvar skipMethods = ['setMaxBounds', 'setMinZoom', 'setMaxZoom', 'setMinPitch', 'setMaxPitch', 'setRenderWorldCopies', 'setProjection', 'setStyle', 'addSource', 'removeSource', 'addLayer', 'removeLayer', 'setLayerZoomRange', 'setFilter', 'setPaintProperty', 'setLayoutProperty', 'setLight', 'setTerrain', 'setFog', 'remove'];\nexport default function createRef(mapInstance, mapLib) {\n  if (!mapInstance) {\n    return null;\n  }\n\n  var map = mapInstance.map;\n  var result = {\n    getMap: function getMap() {\n      return map;\n    },\n    // Overwrite getters to use our shadow transform\n    getCenter: function getCenter() {\n      return mapInstance.transform.center;\n    },\n    getZoom: function getZoom() {\n      return mapInstance.transform.zoom;\n    },\n    getBearing: function getBearing() {\n      return mapInstance.transform.bearing;\n    },\n    getPitch: function getPitch() {\n      return mapInstance.transform.pitch;\n    },\n    getPadding: function getPadding() {\n      return mapInstance.transform.padding;\n    },\n    getBounds: function getBounds() {\n      return mapInstance.transform.getBounds();\n    },\n    project: function project(lnglat) {\n      return mapInstance.transform.locationPoint(mapLib.LngLat.convert(lnglat));\n    },\n    unproject: function unproject(point) {\n      return mapInstance.transform.pointLocation(mapLib.Point.convert(point));\n    }\n  };\n\n  var _iterator = _createForOfIteratorHelper(getMethodNames(map)),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var key = _step.value;\n\n      // @ts-expect-error\n      if (!(key in result) && !skipMethods.includes(key)) {\n        result[key] = map[key].bind(map);\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return result;\n}\n\nfunction getMethodNames(obj) {\n  var result = new Set();\n  var proto = obj;\n\n  while (proto) {\n    var _iterator2 = _createForOfIteratorHelper(Object.getOwnPropertyNames(proto)),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var key = _step2.value;\n\n        if (key[0] !== '_' && typeof obj[key] === 'function' && key !== 'fire' && key !== 'setEventedParent') {\n          result.add(key);\n        }\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n\n    proto = Object.getPrototypeOf(proto);\n  }\n\n  return Array.from(result);\n}","map":{"version":3,"mappings":"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","names":["skipMethods","createRef","mapInstance","mapLib","map","result","getMap","getCenter","transform","center","getZoom","zoom","getBearing","bearing","getPitch","pitch","getPadding","padding","getBounds","project","lnglat","locationPoint","LngLat","convert","unproject","point","pointLocation","Point","getMethodNames","key","includes","bind","obj","Set","proto","Object","getOwnPropertyNames","add","getPrototypeOf","Array","from"],"sources":["/Users/arnavmisra/Desktop/Portfolio-main/Portfolio/node_modules/react-map-gl/src/mapbox/create-ref.ts"],"sourcesContent":["import type {MapboxMap, LngLatLike, PointLike} from '../types';\nimport type Mapbox from './mapbox';\n\n/** These methods may break the react binding if called directly */\nconst skipMethods = [\n  'setMaxBounds',\n  'setMinZoom',\n  'setMaxZoom',\n  'setMinPitch',\n  'setMaxPitch',\n  'setRenderWorldCopies',\n  'setProjection',\n  'setStyle',\n  'addSource',\n  'removeSource',\n  'addLayer',\n  'removeLayer',\n  'setLayerZoomRange',\n  'setFilter',\n  'setPaintProperty',\n  'setLayoutProperty',\n  'setLight',\n  'setTerrain',\n  'setFog',\n  'remove'\n] as const;\n\nexport type MapRef = {\n  getMap(): MapboxMap;\n} & Omit<MapboxMap, typeof skipMethods[number]>;\n\nexport default function createRef(mapInstance: Mapbox, mapLib: any): MapRef {\n  if (!mapInstance) {\n    return null;\n  }\n\n  const map: MapboxMap = mapInstance.map;\n  const result: any = {\n    getMap: () => map,\n\n    // Overwrite getters to use our shadow transform\n    getCenter: () => mapInstance.transform.center,\n    getZoom: () => mapInstance.transform.zoom,\n    getBearing: () => mapInstance.transform.bearing,\n    getPitch: () => mapInstance.transform.pitch,\n    getPadding: () => mapInstance.transform.padding,\n    getBounds: () => mapInstance.transform.getBounds(),\n    project: (lnglat: LngLatLike) => {\n      return mapInstance.transform.locationPoint(mapLib.LngLat.convert(lnglat));\n    },\n    unproject: (point: PointLike) => {\n      return mapInstance.transform.pointLocation(mapLib.Point.convert(point));\n    }\n  };\n\n  for (const key of getMethodNames(map)) {\n    // @ts-expect-error\n    if (!(key in result) && !skipMethods.includes(key)) {\n      result[key] = map[key].bind(map);\n    }\n  }\n\n  return result;\n}\n\nfunction getMethodNames(obj) {\n  const result = new Set<string>();\n\n  let proto = obj;\n  while (proto) {\n    for (const key of Object.getOwnPropertyNames(proto)) {\n      if (\n        key[0] !== '_' &&\n        typeof obj[key] === 'function' &&\n        key !== 'fire' &&\n        key !== 'setEventedParent'\n      ) {\n        result.add(key);\n      }\n    }\n    proto = Object.getPrototypeOf(proto);\n  }\n  return Array.from(result);\n}\n"]},"metadata":{},"sourceType":"module"}