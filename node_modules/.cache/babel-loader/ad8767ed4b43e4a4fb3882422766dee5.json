{"ast":null,"code":"import { __awaiter, __generator } from \"tslib\";\nimport { sleep } from \"./utils/sleep\";\nimport { WaiterState } from \"./waiter\";\n/**\n * Reference: https://awslabs.github.io/smithy/1.0/spec/waiters.html#waiter-retries\n */\n\nvar exponentialBackoffWithJitter = function (minDelay, maxDelay, attemptCeiling, attempt) {\n  if (attempt > attemptCeiling) return maxDelay;\n  var delay = minDelay * Math.pow(2, attempt - 1);\n  return randomInRange(minDelay, delay);\n};\n\nvar randomInRange = function (min, max) {\n  return min + Math.random() * (max - min);\n};\n/**\n * Function that runs polling as part of waiters. This will make one inital attempt and then\n * subsequent attempts with an increasing delay.\n * @param params options passed to the waiter.\n * @param client AWS SDK Client\n * @param input client input\n * @param stateChecker function that checks the acceptor states on each poll.\n */\n\n\nexport var runPolling = function (_a, input, acceptorChecks) {\n  var minDelay = _a.minDelay,\n      maxDelay = _a.maxDelay,\n      maxWaitTime = _a.maxWaitTime,\n      abortController = _a.abortController,\n      client = _a.client;\n  return __awaiter(void 0, void 0, void 0, function () {\n    var state, currentAttempt, waitUntil, attemptCeiling, delay, state_1;\n\n    var _b;\n\n    return __generator(this, function (_c) {\n      switch (_c.label) {\n        case 0:\n          return [4\n          /*yield*/\n          , acceptorChecks(client, input)];\n\n        case 1:\n          state = _c.sent().state;\n\n          if (state !== WaiterState.RETRY) {\n            return [2\n            /*return*/\n            , {\n              state: state\n            }];\n          }\n\n          currentAttempt = 1;\n          waitUntil = Date.now() + maxWaitTime * 1000;\n          attemptCeiling = Math.log(maxDelay / minDelay) / Math.log(2) + 1;\n          _c.label = 2;\n\n        case 2:\n          if (!true) return [3\n          /*break*/\n          , 5];\n\n          if ((_b = abortController === null || abortController === void 0 ? void 0 : abortController.signal) === null || _b === void 0 ? void 0 : _b.aborted) {\n            return [2\n            /*return*/\n            , {\n              state: WaiterState.ABORTED\n            }];\n          }\n\n          delay = exponentialBackoffWithJitter(minDelay, maxDelay, attemptCeiling, currentAttempt); // Resolve the promise explicitly at timeout or aborted. Otherwise this while loop will keep making API call until\n          // `acceptorCheck` returns non-retry status, even with the Promise.race() outside.\n\n          if (Date.now() + delay * 1000 > waitUntil) {\n            return [2\n            /*return*/\n            , {\n              state: WaiterState.TIMEOUT\n            }];\n          }\n\n          return [4\n          /*yield*/\n          , sleep(delay)];\n\n        case 3:\n          _c.sent();\n\n          return [4\n          /*yield*/\n          , acceptorChecks(client, input)];\n\n        case 4:\n          state_1 = _c.sent().state;\n\n          if (state_1 !== WaiterState.RETRY) {\n            return [2\n            /*return*/\n            , {\n              state: state_1\n            }];\n          }\n\n          currentAttempt += 1;\n          return [3\n          /*break*/\n          , 2];\n\n        case 5:\n          return [2\n          /*return*/\n          ];\n      }\n    });\n  });\n};","map":{"version":3,"mappings":"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","names":["sleep","WaiterState","exponentialBackoffWithJitter","minDelay","maxDelay","attemptCeiling","attempt","delay","Math","randomInRange","min","max","random","runPolling","_a","input","acceptorChecks","maxWaitTime","abortController","client","state","_c","RETRY","currentAttempt","waitUntil","Date","now","log","signal","_b","aborted","ABORTED","TIMEOUT","state_1"],"sources":["/Users/arnavmisra/Desktop/Portfolio-main/Portfolio/node_modules/@aws-sdk/util-waiter/src/poller.ts"],"sourcesContent":["import { sleep } from \"./utils/sleep\";\nimport { WaiterOptions, WaiterResult, WaiterState } from \"./waiter\";\n\n/**\n * Reference: https://awslabs.github.io/smithy/1.0/spec/waiters.html#waiter-retries\n */\nconst exponentialBackoffWithJitter = (minDelay: number, maxDelay: number, attemptCeiling: number, attempt: number) => {\n  if (attempt > attemptCeiling) return maxDelay;\n  const delay = minDelay * 2 ** (attempt - 1);\n  return randomInRange(minDelay, delay);\n};\n\nconst randomInRange = (min: number, max: number) => min + Math.random() * (max - min);\n\n/**\n * Function that runs polling as part of waiters. This will make one inital attempt and then\n * subsequent attempts with an increasing delay.\n * @param params options passed to the waiter.\n * @param client AWS SDK Client\n * @param input client input\n * @param stateChecker function that checks the acceptor states on each poll.\n */\nexport const runPolling = async <Client, Input>(\n  { minDelay, maxDelay, maxWaitTime, abortController, client }: WaiterOptions<Client>,\n  input: Input,\n  acceptorChecks: (client: Client, input: Input) => Promise<WaiterResult>\n): Promise<WaiterResult> => {\n  const { state } = await acceptorChecks(client, input);\n  if (state !== WaiterState.RETRY) {\n    return { state };\n  }\n\n  let currentAttempt = 1;\n  const waitUntil = Date.now() + maxWaitTime * 1000;\n  // The max attempt number that the derived delay time tend to increase.\n  // Pre-compute this number to avoid Number type overflow.\n  const attemptCeiling = Math.log(maxDelay / minDelay) / Math.log(2) + 1;\n  while (true) {\n    if (abortController?.signal?.aborted) {\n      return { state: WaiterState.ABORTED };\n    }\n    const delay = exponentialBackoffWithJitter(minDelay, maxDelay, attemptCeiling, currentAttempt);\n    // Resolve the promise explicitly at timeout or aborted. Otherwise this while loop will keep making API call until\n    // `acceptorCheck` returns non-retry status, even with the Promise.race() outside.\n    if (Date.now() + delay * 1000 > waitUntil) {\n      return { state: WaiterState.TIMEOUT };\n    }\n    await sleep(delay);\n    const { state } = await acceptorChecks(client, input);\n    if (state !== WaiterState.RETRY) {\n      return { state };\n    }\n\n    currentAttempt += 1;\n  }\n};\n"]},"metadata":{},"sourceType":"module"}