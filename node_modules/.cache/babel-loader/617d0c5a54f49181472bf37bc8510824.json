{"ast":null,"code":"import * as React from 'react';\nimport { forwardRef, useImperativeHandle, useRef, useEffect } from 'react';\nimport { applyReactStyle } from '../utils/apply-react-style';\nimport useControl from './use-control';\nconst GeolocateControl = forwardRef((props, ref) => {\n  const thisRef = useRef({\n    props\n  });\n  const ctrl = useControl(_ref => {\n    let {\n      mapLib\n    } = _ref;\n    const gc = new mapLib.GeolocateControl(props); // Hack: fix GeolocateControl reuse\n    // When using React strict mode, the component is mounted twice.\n    // GeolocateControl's UI creation is asynchronous. Removing and adding it back causes the UI to be initialized twice.\n\n    const setupUI = gc._setupUI;\n\n    gc._setupUI = args => {\n      if (!gc._container.hasChildNodes()) {\n        setupUI(args);\n      }\n    };\n\n    gc.on('geolocate', e => {\n      var _a, _b;\n\n      (_b = (_a = thisRef.current.props).onGeolocate) === null || _b === void 0 ? void 0 : _b.call(_a, e);\n    });\n    gc.on('error', e => {\n      var _a, _b;\n\n      (_b = (_a = thisRef.current.props).onError) === null || _b === void 0 ? void 0 : _b.call(_a, e);\n    });\n    gc.on('outofmaxbounds', e => {\n      var _a, _b;\n\n      (_b = (_a = thisRef.current.props).onOutOfMaxBounds) === null || _b === void 0 ? void 0 : _b.call(_a, e);\n    });\n    gc.on('trackuserlocationstart', e => {\n      var _a, _b;\n\n      (_b = (_a = thisRef.current.props).onTrackUserLocationStart) === null || _b === void 0 ? void 0 : _b.call(_a, e);\n    });\n    gc.on('trackuserlocationend', e => {\n      var _a, _b;\n\n      (_b = (_a = thisRef.current.props).onTrackUserLocationEnd) === null || _b === void 0 ? void 0 : _b.call(_a, e);\n    });\n    return gc;\n  }, {\n    position: props.position\n  });\n  thisRef.current.props = props;\n  useImperativeHandle(ref, () => ({\n    trigger: () => ctrl.trigger()\n  }), []);\n  useEffect(() => {\n    // @ts-ignore\n    applyReactStyle(ctrl._container, props.style);\n  }, [props.style]);\n  return null;\n});\nGeolocateControl.displayName = 'GeolocateControl';\nexport default React.memo(GeolocateControl);","map":{"version":3,"mappings":"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","names":["React","forwardRef","useImperativeHandle","useRef","useEffect","applyReactStyle","useControl","GeolocateControl","props","ref","thisRef","ctrl","mapLib","gc","setupUI","_setupUI","args","_container","hasChildNodes","on","e","current","onGeolocate","_b","onError","onOutOfMaxBounds","onTrackUserLocationStart","onTrackUserLocationEnd","position","trigger","style","displayName","memo"],"sources":["/Users/arnavmisra/Desktop/Portfolio-main/Portfolio/node_modules/react-map-gl/src/components/geolocate-control.ts"],"sourcesContent":["import * as React from 'react';\nimport {forwardRef, useImperativeHandle, useRef, useEffect} from 'react';\nimport {applyReactStyle} from '../utils/apply-react-style';\nimport useControl from './use-control';\n\nimport type {\n  ControlPosition,\n  PositionOptions,\n  FitBoundsOptions,\n  MapboxGeolocateControl,\n  GeolocateEvent,\n  GeolocateResultEvent,\n  GeolocateErrorEvent\n} from '../types';\n\nexport type GeolocateControlRef = {\n  /** Triggers a geolocate event */\n  trigger: () => boolean;\n};\n\nexport type GeolocateControlProps = {\n  /**\n   * A Geolocation API PositionOptions object.\n   * @default {enableHighAccuracy:false,timeout:6000}\n   */\n  positionOptions?: PositionOptions;\n  /** A Map#fitBounds options object to use when the map is panned and zoomed to the user's location.\n   * @default {maxZoom:15}\n   */\n  fitBoundsOptions?: FitBoundsOptions;\n  /** If true the GeolocateControl becomes a toggle button and when active the map will receive\n   * updates to the user's location as it changes. Default false.\n   * @default false\n   */\n  trackUserLocation?: boolean;\n  /** Draw a transparent circle will be drawn around the user location indicating the accuracy\n   * (95% confidence level) of the user's location. Set to false to disable.\n   * This only has effect if `showUserLocation` is true.\n   * @default true\n   */\n  showAccuracyCircle?: boolean;\n  /**\n   * Show a dot on the map at the user's location. Set to false to disable.\n   * @default true\n   */\n  showUserLocation?: boolean;\n  /** If true an arrow will be drawn next to the user location dot indicating the device's heading.\n   * This only has affect when `trackUserLocation` is true. Default false.\n   * @default false\n   */\n  showUserHeading?: boolean;\n  /** Placement of the control relative to the map. */\n  position?: ControlPosition;\n  /** CSS style override, applied to the control's container */\n  style?: React.CSSProperties;\n\n  /** Called on each Geolocation API position update that returned as success. */\n  onGeolocate?: (e: GeolocateResultEvent) => void;\n  /** Called on each Geolocation API position update that returned as an error. */\n  onError?: (e: GeolocateErrorEvent) => void;\n  /** Called on each Geolocation API position update that returned as success but user position\n   * is out of map `maxBounds`. */\n  onOutOfMaxBounds?: (e: GeolocateResultEvent) => void;\n  /** Called when the GeolocateControl changes to the active lock state. */\n  onTrackUserLocationStart?: (e: GeolocateEvent) => void;\n  /** Called when the GeolocateControl changes to the background state. */\n  onTrackUserLocationEnd?: (e: GeolocateEvent) => void;\n};\n\nconst GeolocateControl = forwardRef<GeolocateControlRef, GeolocateControlProps>((props, ref) => {\n  const thisRef = useRef({props});\n\n  const ctrl = useControl<MapboxGeolocateControl>(\n    ({mapLib}) => {\n      const gc = new mapLib.GeolocateControl(props);\n\n      // Hack: fix GeolocateControl reuse\n      // When using React strict mode, the component is mounted twice.\n      // GeolocateControl's UI creation is asynchronous. Removing and adding it back causes the UI to be initialized twice.\n      const setupUI = gc._setupUI;\n      gc._setupUI = args => {\n        if (!gc._container.hasChildNodes()) {\n          setupUI(args);\n        }\n      };\n\n      gc.on('geolocate', e => {\n        thisRef.current.props.onGeolocate?.(e as GeolocateResultEvent);\n      });\n      gc.on('error', e => {\n        thisRef.current.props.onError?.(e as GeolocateErrorEvent);\n      });\n      gc.on('outofmaxbounds', e => {\n        thisRef.current.props.onOutOfMaxBounds?.(e as GeolocateResultEvent);\n      });\n      gc.on('trackuserlocationstart', e => {\n        thisRef.current.props.onTrackUserLocationStart?.(e as GeolocateEvent);\n      });\n      gc.on('trackuserlocationend', e => {\n        thisRef.current.props.onTrackUserLocationEnd?.(e as GeolocateEvent);\n      });\n\n      return gc;\n    },\n    {position: props.position}\n  );\n\n  thisRef.current.props = props;\n\n  useImperativeHandle(\n    ref,\n    () => ({\n      trigger: () => ctrl.trigger()\n    }),\n    []\n  );\n\n  useEffect(() => {\n    // @ts-ignore\n    applyReactStyle(ctrl._container, props.style);\n  }, [props.style]);\n\n  return null;\n});\n\nGeolocateControl.displayName = 'GeolocateControl';\n\nexport default React.memo(GeolocateControl);\n"]},"metadata":{},"sourceType":"module"}