{"ast":null,"code":"/*\n * Copyright 2017-2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"). You may not use this file except in compliance with\n * the License. A copy of the License is located at\n *\n *     http://aws.amazon.com/apache2.0/\n *\n * or in the \"license\" file accompanying this file. This file is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions\n * and limitations under the License.\n */\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n      m = s && o[s],\n      i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\n\nvar DoubleLinkedNode =\n/** @class */\nfunction () {\n  function DoubleLinkedNode(keyVal) {\n    this.key = keyVal ? keyVal : '';\n    this.prevNode = null;\n    this.nextNode = null;\n  }\n\n  return DoubleLinkedNode;\n}();\n/**\n * double linked list plus a hash table inside\n * each key in the cache stored as a node in the list\n * recently visited node will be rotated to the head\n * so the Last Recently Visited node will be at the tail\n *\n * @member head - dummy head of the linked list\n * @member tail - dummy tail of the linked list\n * @member hashtable - the hashtable which maps cache key to list node\n * @member length - length of the list\n */\n\n\nvar CacheList =\n/** @class */\nfunction () {\n  /**\n   * initialization\n   */\n  function CacheList() {\n    this.head = new DoubleLinkedNode();\n    this.tail = new DoubleLinkedNode();\n    this.hashtable = {};\n    this.length = 0;\n    this.head.nextNode = this.tail;\n    this.tail.prevNode = this.head;\n  }\n  /**\n   * insert node to the head of the list\n   *\n   * @param node\n   */\n\n\n  CacheList.prototype.insertNodeToHead = function (node) {\n    var tmp = this.head.nextNode;\n    this.head.nextNode = node;\n    node.nextNode = tmp;\n    node.prevNode = this.head;\n    tmp.prevNode = node;\n    this.length = this.length + 1;\n  };\n  /**\n   * remove node\n   *\n   * @param node\n   */\n\n\n  CacheList.prototype.removeNode = function (node) {\n    node.prevNode.nextNode = node.nextNode;\n    node.nextNode.prevNode = node.prevNode;\n    node.prevNode = null;\n    node.nextNode = null;\n    this.length = this.length - 1;\n  };\n  /**\n   * @return true if list is empty\n   */\n\n\n  CacheList.prototype.isEmpty = function () {\n    return this.length === 0;\n  };\n  /**\n   * refresh node so it is rotated to the head\n   *\n   * @param key - key of the node\n   */\n\n\n  CacheList.prototype.refresh = function (key) {\n    var node = this.hashtable[key];\n    this.removeNode(node);\n    this.insertNodeToHead(node);\n  };\n  /**\n   * insert new node to the head and add it in the hashtable\n   *\n   * @param key - the key of the node\n   */\n\n\n  CacheList.prototype.insertItem = function (key) {\n    var node = new DoubleLinkedNode(key);\n    this.hashtable[key] = node;\n    this.insertNodeToHead(node);\n  };\n  /**\n   * @return the LAST Recently Visited key\n   */\n\n\n  CacheList.prototype.getLastItem = function () {\n    return this.tail.prevNode.key;\n  };\n  /**\n   * remove the cache key from the list and hashtable\n   * @param key - the key of the node\n   */\n\n\n  CacheList.prototype.removeItem = function (key) {\n    var removedItem = this.hashtable[key];\n    this.removeNode(removedItem);\n    delete this.hashtable[key];\n  };\n  /**\n   * @return length of the list\n   */\n\n\n  CacheList.prototype.getSize = function () {\n    return this.length;\n  };\n  /**\n   * @return true if the key is in the hashtable\n   * @param key\n   */\n\n\n  CacheList.prototype.containsKey = function (key) {\n    return key in this.hashtable;\n  };\n  /**\n   * clean up the list and hashtable\n   */\n\n\n  CacheList.prototype.clearList = function () {\n    var e_1, _a;\n\n    try {\n      for (var _b = __values(Object.keys(this.hashtable)), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var key = _c.value;\n\n        if (this.hashtable.hasOwnProperty(key)) {\n          delete this.hashtable[key];\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n\n    this.head.nextNode = this.tail;\n    this.tail.prevNode = this.head;\n    this.length = 0;\n  };\n  /**\n   * @return all keys in the hashtable\n   */\n\n\n  CacheList.prototype.getKeys = function () {\n    return Object.keys(this.hashtable);\n  };\n  /**\n   * mainly for test\n   *\n   * @param key\n   * @return true if key is the head node\n   */\n\n\n  CacheList.prototype.isHeadNode = function (key) {\n    var node = this.hashtable[key];\n    return node.prevNode === this.head;\n  };\n  /**\n   * mainly for test\n   *\n   * @param key\n   * @return true if key is the tail node\n   */\n\n\n  CacheList.prototype.isTailNode = function (key) {\n    var node = this.hashtable[key];\n    return node.nextNode === this.tail;\n  };\n\n  return CacheList;\n}();\n\nexport default CacheList;","map":{"version":3,"mappings":"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","names":["keyVal","key","prevNode","nextNode","head","DoubleLinkedNode","tail","hashtable","length","CacheList","node","tmp","removeNode","insertNodeToHead","removedItem","keys","_c","hasOwnProperty","Object"],"sources":["/Users/arnavmisra/Desktop/Portfolio-main/node_modules/@aws-amplify/cache/src/Utils/CacheList.ts"],"sourcesContent":["/*\r\n * Copyright 2017-2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\"). You may not use this file except in compliance with\r\n * the License. A copy of the License is located at\r\n *\r\n *     http://aws.amazon.com/apache2.0/\r\n *\r\n * or in the \"license\" file accompanying this file. This file is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\r\n * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions\r\n * and limitations under the License.\r\n */\r\n\r\nclass DoubleLinkedNode {\r\n\tkey: string;\r\n\tprevNode: DoubleLinkedNode | null;\r\n\tnextNode: DoubleLinkedNode | null;\r\n\r\n\tconstructor(keyVal?: string) {\r\n\t\tthis.key = keyVal ? keyVal : '';\r\n\t\tthis.prevNode = null;\r\n\t\tthis.nextNode = null;\r\n\t}\r\n}\r\n\r\n/**\r\n * double linked list plus a hash table inside\r\n * each key in the cache stored as a node in the list\r\n * recently visited node will be rotated to the head\r\n * so the Last Recently Visited node will be at the tail\r\n *\r\n * @member head - dummy head of the linked list\r\n * @member tail - dummy tail of the linked list\r\n * @member hashtable - the hashtable which maps cache key to list node\r\n * @member length - length of the list\r\n */\r\nexport default class CacheList {\r\n\tprivate head: DoubleLinkedNode;\r\n\tprivate tail: DoubleLinkedNode;\r\n\tprivate hashtable: object;\r\n\tprivate length: number;\r\n\r\n\t/**\r\n\t * initialization\r\n\t */\r\n\tconstructor() {\r\n\t\tthis.head = new DoubleLinkedNode();\r\n\t\tthis.tail = new DoubleLinkedNode();\r\n\t\tthis.hashtable = {};\r\n\t\tthis.length = 0;\r\n\r\n\t\tthis.head.nextNode = this.tail;\r\n\t\tthis.tail.prevNode = this.head;\r\n\t}\r\n\r\n\t/**\r\n\t * insert node to the head of the list\r\n\t *\r\n\t * @param node\r\n\t */\r\n\tprivate insertNodeToHead(node: DoubleLinkedNode) {\r\n\t\tconst tmp: DoubleLinkedNode = this.head.nextNode;\r\n\t\tthis.head.nextNode = node;\r\n\t\tnode.nextNode = tmp;\r\n\t\tnode.prevNode = this.head;\r\n\t\ttmp.prevNode = node;\r\n\r\n\t\tthis.length = this.length + 1;\r\n\t}\r\n\r\n\t/**\r\n\t * remove node\r\n\t *\r\n\t * @param node\r\n\t */\r\n\tprivate removeNode(node: DoubleLinkedNode): void {\r\n\t\tnode.prevNode.nextNode = node.nextNode;\r\n\t\tnode.nextNode.prevNode = node.prevNode;\r\n\r\n\t\tnode.prevNode = null;\r\n\t\tnode.nextNode = null;\r\n\r\n\t\tthis.length = this.length - 1;\r\n\t}\r\n\r\n\t/**\r\n\t * @return true if list is empty\r\n\t */\r\n\tpublic isEmpty(): boolean {\r\n\t\treturn this.length === 0;\r\n\t}\r\n\r\n\t/**\r\n\t * refresh node so it is rotated to the head\r\n\t *\r\n\t * @param key - key of the node\r\n\t */\r\n\tpublic refresh(key: string): void {\r\n\t\tconst node: DoubleLinkedNode = this.hashtable[key];\r\n\t\tthis.removeNode(node);\r\n\t\tthis.insertNodeToHead(node);\r\n\t}\r\n\r\n\t/**\r\n\t * insert new node to the head and add it in the hashtable\r\n\t *\r\n\t * @param key - the key of the node\r\n\t */\r\n\tpublic insertItem(key: string): void {\r\n\t\tconst node: DoubleLinkedNode = new DoubleLinkedNode(key);\r\n\t\tthis.hashtable[key] = node;\r\n\t\tthis.insertNodeToHead(node);\r\n\t}\r\n\r\n\t/**\r\n\t * @return the LAST Recently Visited key\r\n\t */\r\n\tpublic getLastItem(): string {\r\n\t\treturn this.tail.prevNode.key;\r\n\t}\r\n\r\n\t/**\r\n\t * remove the cache key from the list and hashtable\r\n\t * @param key - the key of the node\r\n\t */\r\n\tpublic removeItem(key: string): void {\r\n\t\tconst removedItem: DoubleLinkedNode = this.hashtable[key];\r\n\t\tthis.removeNode(removedItem);\r\n\t\tdelete this.hashtable[key];\r\n\t}\r\n\r\n\t/**\r\n\t * @return length of the list\r\n\t */\r\n\tpublic getSize(): number {\r\n\t\treturn this.length;\r\n\t}\r\n\r\n\t/**\r\n\t * @return true if the key is in the hashtable\r\n\t * @param key\r\n\t */\r\n\tpublic containsKey(key: string): boolean {\r\n\t\treturn key in this.hashtable;\r\n\t}\r\n\r\n\t/**\r\n\t * clean up the list and hashtable\r\n\t */\r\n\tpublic clearList(): void {\r\n\t\tfor (const key of Object.keys(this.hashtable)) {\r\n\t\t\tif (this.hashtable.hasOwnProperty(key)) {\r\n\t\t\t\tdelete this.hashtable[key];\r\n\t\t\t}\r\n\t\t}\r\n\t\tthis.head.nextNode = this.tail;\r\n\t\tthis.tail.prevNode = this.head;\r\n\t\tthis.length = 0;\r\n\t}\r\n\r\n\t/**\r\n\t * @return all keys in the hashtable\r\n\t */\r\n\tpublic getKeys(): string[] {\r\n\t\treturn Object.keys(this.hashtable);\r\n\t}\r\n\r\n\t/**\r\n\t * mainly for test\r\n\t *\r\n\t * @param key\r\n\t * @return true if key is the head node\r\n\t */\r\n\tpublic isHeadNode(key: string): boolean {\r\n\t\tconst node = this.hashtable[key];\r\n\t\treturn node.prevNode === this.head;\r\n\t}\r\n\r\n\t/**\r\n\t * mainly for test\r\n\t *\r\n\t * @param key\r\n\t * @return true if key is the tail node\r\n\t */\r\n\tpublic isTailNode(key: string): boolean {\r\n\t\tconst node = this.hashtable[key];\r\n\t\treturn node.nextNode === this.tail;\r\n\t}\r\n}\r\n"]},"metadata":{},"sourceType":"module"}