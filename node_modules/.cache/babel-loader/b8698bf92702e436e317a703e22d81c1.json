{"ast":null,"code":"import { __awaiter, __generator } from \"tslib\";\nimport { toHex } from \"@aws-sdk/util-hex-encoding\";\nimport { ALGORITHM_IDENTIFIER, ALGORITHM_QUERY_PARAM, AMZ_DATE_HEADER, AMZ_DATE_QUERY_PARAM, AUTH_HEADER, CREDENTIAL_QUERY_PARAM, EVENT_ALGORITHM_IDENTIFIER, EXPIRES_QUERY_PARAM, MAX_PRESIGNED_TTL, SHA256_HEADER, SIGNATURE_QUERY_PARAM, SIGNED_HEADERS_QUERY_PARAM, TOKEN_HEADER, TOKEN_QUERY_PARAM } from \"./constants\";\nimport { createScope, getSigningKey } from \"./credentialDerivation\";\nimport { getCanonicalHeaders } from \"./getCanonicalHeaders\";\nimport { getCanonicalQuery } from \"./getCanonicalQuery\";\nimport { getPayloadHash } from \"./getPayloadHash\";\nimport { hasHeader } from \"./hasHeader\";\nimport { moveHeadersToQuery } from \"./moveHeadersToQuery\";\nimport { prepareRequest } from \"./prepareRequest\";\nimport { iso8601 } from \"./utilDate\";\n\nvar SignatureV4 =\n/** @class */\nfunction () {\n  function SignatureV4(_a) {\n    var applyChecksum = _a.applyChecksum,\n        credentials = _a.credentials,\n        region = _a.region,\n        service = _a.service,\n        sha256 = _a.sha256,\n        _b = _a.uriEscapePath,\n        uriEscapePath = _b === void 0 ? true : _b;\n    this.service = service;\n    this.sha256 = sha256;\n    this.uriEscapePath = uriEscapePath; // default to true if applyChecksum isn't set\n\n    this.applyChecksum = typeof applyChecksum === \"boolean\" ? applyChecksum : true;\n    this.regionProvider = normalizeRegionProvider(region);\n    this.credentialProvider = normalizeCredentialsProvider(credentials);\n  }\n\n  SignatureV4.prototype.presign = function (originalRequest, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    return __awaiter(this, void 0, void 0, function () {\n      var _a, signingDate, _b, expiresIn, unsignableHeaders, unhoistableHeaders, signableHeaders, signingRegion, signingService, credentials, region, _c, _d, longDate, shortDate, scope, request, canonicalHeaders, _e, _f, _g, _h, _j, _k;\n\n      return __generator(this, function (_l) {\n        switch (_l.label) {\n          case 0:\n            _a = options.signingDate, signingDate = _a === void 0 ? new Date() : _a, _b = options.expiresIn, expiresIn = _b === void 0 ? 3600 : _b, unsignableHeaders = options.unsignableHeaders, unhoistableHeaders = options.unhoistableHeaders, signableHeaders = options.signableHeaders, signingRegion = options.signingRegion, signingService = options.signingService;\n            return [4\n            /*yield*/\n            , this.credentialProvider()];\n\n          case 1:\n            credentials = _l.sent();\n            if (!(signingRegion !== null && signingRegion !== void 0)) return [3\n            /*break*/\n            , 2];\n            _c = signingRegion;\n            return [3\n            /*break*/\n            , 4];\n\n          case 2:\n            return [4\n            /*yield*/\n            , this.regionProvider()];\n\n          case 3:\n            _c = _l.sent();\n            _l.label = 4;\n\n          case 4:\n            region = _c;\n            _d = formatDate(signingDate), longDate = _d.longDate, shortDate = _d.shortDate;\n\n            if (expiresIn > MAX_PRESIGNED_TTL) {\n              return [2\n              /*return*/\n              , Promise.reject(\"Signature version 4 presigned URLs\" + \" must have an expiration date less than one week in\" + \" the future\")];\n            }\n\n            scope = createScope(shortDate, region, signingService !== null && signingService !== void 0 ? signingService : this.service);\n            request = moveHeadersToQuery(prepareRequest(originalRequest), {\n              unhoistableHeaders: unhoistableHeaders\n            });\n\n            if (credentials.sessionToken) {\n              request.query[TOKEN_QUERY_PARAM] = credentials.sessionToken;\n            }\n\n            request.query[ALGORITHM_QUERY_PARAM] = ALGORITHM_IDENTIFIER;\n            request.query[CREDENTIAL_QUERY_PARAM] = credentials.accessKeyId + \"/\" + scope;\n            request.query[AMZ_DATE_QUERY_PARAM] = longDate;\n            request.query[EXPIRES_QUERY_PARAM] = expiresIn.toString(10);\n            canonicalHeaders = getCanonicalHeaders(request, unsignableHeaders, signableHeaders);\n            request.query[SIGNED_HEADERS_QUERY_PARAM] = getCanonicalHeaderList(canonicalHeaders);\n            _e = request.query;\n            _f = SIGNATURE_QUERY_PARAM;\n            _g = this.getSignature;\n            _h = [longDate, scope, this.getSigningKey(credentials, region, shortDate, signingService)];\n            _j = this.createCanonicalRequest;\n            _k = [request, canonicalHeaders];\n            return [4\n            /*yield*/\n            , getPayloadHash(originalRequest, this.sha256)];\n\n          case 5:\n            return [4\n            /*yield*/\n            , _g.apply(this, _h.concat([_j.apply(this, _k.concat([_l.sent()]))]))];\n\n          case 6:\n            _e[_f] = _l.sent();\n            return [2\n            /*return*/\n            , request];\n        }\n      });\n    });\n  };\n\n  SignatureV4.prototype.sign = function (toSign, options) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        if (typeof toSign === \"string\") {\n          return [2\n          /*return*/\n          , this.signString(toSign, options)];\n        } else if (toSign.headers && toSign.payload) {\n          return [2\n          /*return*/\n          , this.signEvent(toSign, options)];\n        } else {\n          return [2\n          /*return*/\n          , this.signRequest(toSign, options)];\n        }\n\n        return [2\n        /*return*/\n        ];\n      });\n    });\n  };\n\n  SignatureV4.prototype.signEvent = function (_a, _b) {\n    var headers = _a.headers,\n        payload = _a.payload;\n    var _c = _b.signingDate,\n        signingDate = _c === void 0 ? new Date() : _c,\n        priorSignature = _b.priorSignature,\n        signingRegion = _b.signingRegion,\n        signingService = _b.signingService;\n    return __awaiter(this, void 0, void 0, function () {\n      var region, _d, _e, shortDate, longDate, scope, hashedPayload, hash, hashedHeaders, _f, stringToSign;\n\n      return __generator(this, function (_g) {\n        switch (_g.label) {\n          case 0:\n            if (!(signingRegion !== null && signingRegion !== void 0)) return [3\n            /*break*/\n            , 1];\n            _d = signingRegion;\n            return [3\n            /*break*/\n            , 3];\n\n          case 1:\n            return [4\n            /*yield*/\n            , this.regionProvider()];\n\n          case 2:\n            _d = _g.sent();\n            _g.label = 3;\n\n          case 3:\n            region = _d;\n            _e = formatDate(signingDate), shortDate = _e.shortDate, longDate = _e.longDate;\n            scope = createScope(shortDate, region, signingService !== null && signingService !== void 0 ? signingService : this.service);\n            return [4\n            /*yield*/\n            , getPayloadHash({\n              headers: {},\n              body: payload\n            }, this.sha256)];\n\n          case 4:\n            hashedPayload = _g.sent();\n            hash = new this.sha256();\n            hash.update(headers);\n            _f = toHex;\n            return [4\n            /*yield*/\n            , hash.digest()];\n\n          case 5:\n            hashedHeaders = _f.apply(void 0, [_g.sent()]);\n            stringToSign = [EVENT_ALGORITHM_IDENTIFIER, longDate, scope, priorSignature, hashedHeaders, hashedPayload].join(\"\\n\");\n            return [2\n            /*return*/\n            , this.signString(stringToSign, {\n              signingDate: signingDate,\n              signingRegion: region,\n              signingService: signingService\n            })];\n        }\n      });\n    });\n  };\n\n  SignatureV4.prototype.signString = function (stringToSign, _a) {\n    var _b = _a === void 0 ? {} : _a,\n        _c = _b.signingDate,\n        signingDate = _c === void 0 ? new Date() : _c,\n        signingRegion = _b.signingRegion,\n        signingService = _b.signingService;\n\n    return __awaiter(this, void 0, void 0, function () {\n      var credentials, region, _d, shortDate, hash, _e, _f, _g;\n\n      return __generator(this, function (_h) {\n        switch (_h.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.credentialProvider()];\n\n          case 1:\n            credentials = _h.sent();\n            if (!(signingRegion !== null && signingRegion !== void 0)) return [3\n            /*break*/\n            , 2];\n            _d = signingRegion;\n            return [3\n            /*break*/\n            , 4];\n\n          case 2:\n            return [4\n            /*yield*/\n            , this.regionProvider()];\n\n          case 3:\n            _d = _h.sent();\n            _h.label = 4;\n\n          case 4:\n            region = _d;\n            shortDate = formatDate(signingDate).shortDate;\n            _f = (_e = this.sha256).bind;\n            return [4\n            /*yield*/\n            , this.getSigningKey(credentials, region, shortDate, signingService)];\n\n          case 5:\n            hash = new (_f.apply(_e, [void 0, _h.sent()]))();\n            hash.update(stringToSign);\n            _g = toHex;\n            return [4\n            /*yield*/\n            , hash.digest()];\n\n          case 6:\n            return [2\n            /*return*/\n            , _g.apply(void 0, [_h.sent()])];\n        }\n      });\n    });\n  };\n\n  SignatureV4.prototype.signRequest = function (requestToSign, _a) {\n    var _b = _a === void 0 ? {} : _a,\n        _c = _b.signingDate,\n        signingDate = _c === void 0 ? new Date() : _c,\n        signableHeaders = _b.signableHeaders,\n        unsignableHeaders = _b.unsignableHeaders,\n        signingRegion = _b.signingRegion,\n        signingService = _b.signingService;\n\n    return __awaiter(this, void 0, void 0, function () {\n      var credentials, region, _d, request, _e, longDate, shortDate, scope, payloadHash, canonicalHeaders, signature;\n\n      return __generator(this, function (_f) {\n        switch (_f.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.credentialProvider()];\n\n          case 1:\n            credentials = _f.sent();\n            if (!(signingRegion !== null && signingRegion !== void 0)) return [3\n            /*break*/\n            , 2];\n            _d = signingRegion;\n            return [3\n            /*break*/\n            , 4];\n\n          case 2:\n            return [4\n            /*yield*/\n            , this.regionProvider()];\n\n          case 3:\n            _d = _f.sent();\n            _f.label = 4;\n\n          case 4:\n            region = _d;\n            request = prepareRequest(requestToSign);\n            _e = formatDate(signingDate), longDate = _e.longDate, shortDate = _e.shortDate;\n            scope = createScope(shortDate, region, signingService !== null && signingService !== void 0 ? signingService : this.service);\n            request.headers[AMZ_DATE_HEADER] = longDate;\n\n            if (credentials.sessionToken) {\n              request.headers[TOKEN_HEADER] = credentials.sessionToken;\n            }\n\n            return [4\n            /*yield*/\n            , getPayloadHash(request, this.sha256)];\n\n          case 5:\n            payloadHash = _f.sent();\n\n            if (!hasHeader(SHA256_HEADER, request.headers) && this.applyChecksum) {\n              request.headers[SHA256_HEADER] = payloadHash;\n            }\n\n            canonicalHeaders = getCanonicalHeaders(request, unsignableHeaders, signableHeaders);\n            return [4\n            /*yield*/\n            , this.getSignature(longDate, scope, this.getSigningKey(credentials, region, shortDate, signingService), this.createCanonicalRequest(request, canonicalHeaders, payloadHash))];\n\n          case 6:\n            signature = _f.sent();\n            request.headers[AUTH_HEADER] = ALGORITHM_IDENTIFIER + \" \" + (\"Credential=\" + credentials.accessKeyId + \"/\" + scope + \", \") + (\"SignedHeaders=\" + getCanonicalHeaderList(canonicalHeaders) + \", \") + (\"Signature=\" + signature);\n            return [2\n            /*return*/\n            , request];\n        }\n      });\n    });\n  };\n\n  SignatureV4.prototype.createCanonicalRequest = function (request, canonicalHeaders, payloadHash) {\n    var sortedHeaders = Object.keys(canonicalHeaders).sort();\n    return request.method + \"\\n\" + this.getCanonicalPath(request) + \"\\n\" + getCanonicalQuery(request) + \"\\n\" + sortedHeaders.map(function (name) {\n      return name + \":\" + canonicalHeaders[name];\n    }).join(\"\\n\") + \"\\n\\n\" + sortedHeaders.join(\";\") + \"\\n\" + payloadHash;\n  };\n\n  SignatureV4.prototype.createStringToSign = function (longDate, credentialScope, canonicalRequest) {\n    return __awaiter(this, void 0, void 0, function () {\n      var hash, hashedRequest;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            hash = new this.sha256();\n            hash.update(canonicalRequest);\n            return [4\n            /*yield*/\n            , hash.digest()];\n\n          case 1:\n            hashedRequest = _a.sent();\n            return [2\n            /*return*/\n            , ALGORITHM_IDENTIFIER + \"\\n\" + longDate + \"\\n\" + credentialScope + \"\\n\" + toHex(hashedRequest)];\n        }\n      });\n    });\n  };\n\n  SignatureV4.prototype.getCanonicalPath = function (_a) {\n    var path = _a.path;\n\n    if (this.uriEscapePath) {\n      var doubleEncoded = encodeURIComponent(path.replace(/^\\//, \"\"));\n      return \"/\" + doubleEncoded.replace(/%2F/g, \"/\");\n    }\n\n    return path;\n  };\n\n  SignatureV4.prototype.getSignature = function (longDate, credentialScope, keyPromise, canonicalRequest) {\n    return __awaiter(this, void 0, void 0, function () {\n      var stringToSign, hash, _a, _b, _c;\n\n      return __generator(this, function (_d) {\n        switch (_d.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.createStringToSign(longDate, credentialScope, canonicalRequest)];\n\n          case 1:\n            stringToSign = _d.sent();\n            _b = (_a = this.sha256).bind;\n            return [4\n            /*yield*/\n            , keyPromise];\n\n          case 2:\n            hash = new (_b.apply(_a, [void 0, _d.sent()]))();\n            hash.update(stringToSign);\n            _c = toHex;\n            return [4\n            /*yield*/\n            , hash.digest()];\n\n          case 3:\n            return [2\n            /*return*/\n            , _c.apply(void 0, [_d.sent()])];\n        }\n      });\n    });\n  };\n\n  SignatureV4.prototype.getSigningKey = function (credentials, region, shortDate, service) {\n    return getSigningKey(this.sha256, credentials, shortDate, region, service || this.service);\n  };\n\n  return SignatureV4;\n}();\n\nexport { SignatureV4 };\n\nvar formatDate = function (now) {\n  var longDate = iso8601(now).replace(/[\\-:]/g, \"\");\n  return {\n    longDate: longDate,\n    shortDate: longDate.substr(0, 8)\n  };\n};\n\nvar getCanonicalHeaderList = function (headers) {\n  return Object.keys(headers).sort().join(\";\");\n};\n\nvar normalizeRegionProvider = function (region) {\n  if (typeof region === \"string\") {\n    var promisified_1 = Promise.resolve(region);\n    return function () {\n      return promisified_1;\n    };\n  } else {\n    return region;\n  }\n};\n\nvar normalizeCredentialsProvider = function (credentials) {\n  if (typeof credentials === \"object\") {\n    var promisified_2 = Promise.resolve(credentials);\n    return function () {\n      return promisified_2;\n    };\n  } else {\n    return credentials;\n  }\n};","map":{"version":3,"mappings":"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","names":["toHex","ALGORITHM_IDENTIFIER","ALGORITHM_QUERY_PARAM","AMZ_DATE_HEADER","AMZ_DATE_QUERY_PARAM","AUTH_HEADER","CREDENTIAL_QUERY_PARAM","EVENT_ALGORITHM_IDENTIFIER","EXPIRES_QUERY_PARAM","MAX_PRESIGNED_TTL","SHA256_HEADER","SIGNATURE_QUERY_PARAM","SIGNED_HEADERS_QUERY_PARAM","TOKEN_HEADER","TOKEN_QUERY_PARAM","createScope","getSigningKey","getCanonicalHeaders","getCanonicalQuery","getPayloadHash","hasHeader","moveHeadersToQuery","prepareRequest","iso8601","_a","applyChecksum","credentials","region","service","sha256","_b","uriEscapePath","regionProvider","normalizeRegionProvider","credentialProvider","normalizeCredentialsProvider","SignatureV4","originalRequest","options","Date","expiresIn","unsignableHeaders","unhoistableHeaders","signableHeaders","signingRegion","signingService","_l","_c","_d","formatDate","signingDate","longDate","shortDate","Promise","reject","scope","request","sessionToken","query","accessKeyId","toString","canonicalHeaders","getCanonicalHeaderList","_e","_f","_g","getSignature","_j","createCanonicalRequest","_h","_k","toSign","signString","headers","payload","signEvent","signRequest","priorSignature","body","hashedPayload","hash","update","digest","hashedHeaders","stringToSign","join","bind","requestToSign","payloadHash","signature","sortedHeaders","Object","keys","sort","method","getCanonicalPath","map","name","credentialScope","canonicalRequest","hashedRequest","path","doubleEncoded","encodeURIComponent","replace","keyPromise","createStringToSign","now","substr","promisified_1","resolve","promisified_2"],"sources":["/Users/arnavmisra/Desktop/Portfolio-main/Portfolio/node_modules/@aws-sdk/signature-v4/src/SignatureV4.ts"],"sourcesContent":["import {\n  Credentials,\n  DateInput,\n  EventSigner,\n  EventSigningArguments,\n  FormattedEvent,\n  HashConstructor,\n  HeaderBag,\n  HttpRequest,\n  Provider,\n  RequestPresigner,\n  RequestPresigningArguments,\n  RequestSigner,\n  RequestSigningArguments,\n  SigningArguments,\n  StringSigner,\n} from \"@aws-sdk/types\";\nimport { toHex } from \"@aws-sdk/util-hex-encoding\";\n\nimport {\n  ALGORITHM_IDENTIFIER,\n  ALGORITHM_QUERY_PARAM,\n  AMZ_DATE_HEADER,\n  AMZ_DATE_QUERY_PARAM,\n  AUTH_HEADER,\n  CREDENTIAL_QUERY_PARAM,\n  EVENT_ALGORITHM_IDENTIFIER,\n  EXPIRES_QUERY_PARAM,\n  MAX_PRESIGNED_TTL,\n  SHA256_HEADER,\n  SIGNATURE_QUERY_PARAM,\n  SIGNED_HEADERS_QUERY_PARAM,\n  TOKEN_HEADER,\n  TOKEN_QUERY_PARAM,\n} from \"./constants\";\nimport { createScope, getSigningKey } from \"./credentialDerivation\";\nimport { getCanonicalHeaders } from \"./getCanonicalHeaders\";\nimport { getCanonicalQuery } from \"./getCanonicalQuery\";\nimport { getPayloadHash } from \"./getPayloadHash\";\nimport { hasHeader } from \"./hasHeader\";\nimport { moveHeadersToQuery } from \"./moveHeadersToQuery\";\nimport { prepareRequest } from \"./prepareRequest\";\nimport { iso8601 } from \"./utilDate\";\n\nexport interface SignatureV4Init {\n  /**\n   * The service signing name.\n   */\n  service: string;\n\n  /**\n   * The region name or a function that returns a promise that will be\n   * resolved with the region name.\n   */\n  region: string | Provider<string>;\n\n  /**\n   * The credentials with which the request should be signed or a function\n   * that returns a promise that will be resolved with credentials.\n   */\n  credentials: Credentials | Provider<Credentials>;\n\n  /**\n   * A constructor function for a hash object that will calculate SHA-256 HMAC\n   * checksums.\n   */\n  sha256?: HashConstructor;\n\n  /**\n   * Whether to uri-escape the request URI path as part of computing the\n   * canonical request string. This is required for every AWS service, except\n   * Amazon S3, as of late 2017.\n   *\n   * @default [true]\n   */\n  uriEscapePath?: boolean;\n\n  /**\n   * Whether to calculate a checksum of the request body and include it as\n   * either a request header (when signing) or as a query string parameter\n   * (when presigning). This is required for AWS Glacier and Amazon S3 and optional for\n   * every other AWS service as of late 2017.\n   *\n   * @default [true]\n   */\n  applyChecksum?: boolean;\n}\n\nexport interface SignatureV4CryptoInit {\n  sha256: HashConstructor;\n}\n\nexport class SignatureV4 implements RequestPresigner, RequestSigner, StringSigner, EventSigner {\n  private readonly service: string;\n  private readonly regionProvider: Provider<string>;\n  private readonly credentialProvider: Provider<Credentials>;\n  private readonly sha256: HashConstructor;\n  private readonly uriEscapePath: boolean;\n  private readonly applyChecksum: boolean;\n\n  constructor({\n    applyChecksum,\n    credentials,\n    region,\n    service,\n    sha256,\n    uriEscapePath = true,\n  }: SignatureV4Init & SignatureV4CryptoInit) {\n    this.service = service;\n    this.sha256 = sha256;\n    this.uriEscapePath = uriEscapePath;\n    // default to true if applyChecksum isn't set\n    this.applyChecksum = typeof applyChecksum === \"boolean\" ? applyChecksum : true;\n    this.regionProvider = normalizeRegionProvider(region);\n    this.credentialProvider = normalizeCredentialsProvider(credentials);\n  }\n\n  public async presign(originalRequest: HttpRequest, options: RequestPresigningArguments = {}): Promise<HttpRequest> {\n    const {\n      signingDate = new Date(),\n      expiresIn = 3600,\n      unsignableHeaders,\n      unhoistableHeaders,\n      signableHeaders,\n      signingRegion,\n      signingService,\n    } = options;\n    const credentials = await this.credentialProvider();\n    const region = signingRegion ?? (await this.regionProvider());\n\n    const { longDate, shortDate } = formatDate(signingDate);\n    if (expiresIn > MAX_PRESIGNED_TTL) {\n      return Promise.reject(\n        \"Signature version 4 presigned URLs\" + \" must have an expiration date less than one week in\" + \" the future\"\n      );\n    }\n\n    const scope = createScope(shortDate, region, signingService ?? this.service);\n    const request = moveHeadersToQuery(prepareRequest(originalRequest), { unhoistableHeaders });\n\n    if (credentials.sessionToken) {\n      request.query[TOKEN_QUERY_PARAM] = credentials.sessionToken;\n    }\n    request.query[ALGORITHM_QUERY_PARAM] = ALGORITHM_IDENTIFIER;\n    request.query[CREDENTIAL_QUERY_PARAM] = `${credentials.accessKeyId}/${scope}`;\n    request.query[AMZ_DATE_QUERY_PARAM] = longDate;\n    request.query[EXPIRES_QUERY_PARAM] = expiresIn.toString(10);\n\n    const canonicalHeaders = getCanonicalHeaders(request, unsignableHeaders, signableHeaders);\n    request.query[SIGNED_HEADERS_QUERY_PARAM] = getCanonicalHeaderList(canonicalHeaders);\n\n    request.query[SIGNATURE_QUERY_PARAM] = await this.getSignature(\n      longDate,\n      scope,\n      this.getSigningKey(credentials, region, shortDate, signingService),\n      this.createCanonicalRequest(request, canonicalHeaders, await getPayloadHash(originalRequest, this.sha256))\n    );\n\n    return request;\n  }\n\n  public async sign(stringToSign: string, options?: SigningArguments): Promise<string>;\n  public async sign(event: FormattedEvent, options: EventSigningArguments): Promise<string>;\n  public async sign(requestToSign: HttpRequest, options?: RequestSigningArguments): Promise<HttpRequest>;\n  public async sign(toSign: any, options: any): Promise<any> {\n    if (typeof toSign === \"string\") {\n      return this.signString(toSign, options);\n    } else if (toSign.headers && toSign.payload) {\n      return this.signEvent(toSign, options);\n    } else {\n      return this.signRequest(toSign, options);\n    }\n  }\n\n  private async signEvent(\n    { headers, payload }: FormattedEvent,\n    { signingDate = new Date(), priorSignature, signingRegion, signingService }: EventSigningArguments\n  ): Promise<string> {\n    const region = signingRegion ?? (await this.regionProvider());\n    const { shortDate, longDate } = formatDate(signingDate);\n    const scope = createScope(shortDate, region, signingService ?? this.service);\n    const hashedPayload = await getPayloadHash({ headers: {}, body: payload } as any, this.sha256);\n    const hash = new this.sha256();\n    hash.update(headers);\n    const hashedHeaders = toHex(await hash.digest());\n    const stringToSign = [\n      EVENT_ALGORITHM_IDENTIFIER,\n      longDate,\n      scope,\n      priorSignature,\n      hashedHeaders,\n      hashedPayload,\n    ].join(\"\\n\");\n    return this.signString(stringToSign, { signingDate, signingRegion: region, signingService });\n  }\n\n  private async signString(\n    stringToSign: string,\n    { signingDate = new Date(), signingRegion, signingService }: SigningArguments = {}\n  ): Promise<string> {\n    const credentials = await this.credentialProvider();\n    const region = signingRegion ?? (await this.regionProvider());\n    const { shortDate } = formatDate(signingDate);\n\n    const hash = new this.sha256(await this.getSigningKey(credentials, region, shortDate, signingService));\n    hash.update(stringToSign);\n    return toHex(await hash.digest());\n  }\n\n  private async signRequest(\n    requestToSign: HttpRequest,\n    {\n      signingDate = new Date(),\n      signableHeaders,\n      unsignableHeaders,\n      signingRegion,\n      signingService,\n    }: RequestSigningArguments = {}\n  ): Promise<HttpRequest> {\n    const credentials = await this.credentialProvider();\n    const region = signingRegion ?? (await this.regionProvider());\n    const request = prepareRequest(requestToSign);\n    const { longDate, shortDate } = formatDate(signingDate);\n    const scope = createScope(shortDate, region, signingService ?? this.service);\n\n    request.headers[AMZ_DATE_HEADER] = longDate;\n    if (credentials.sessionToken) {\n      request.headers[TOKEN_HEADER] = credentials.sessionToken;\n    }\n\n    const payloadHash = await getPayloadHash(request, this.sha256);\n    if (!hasHeader(SHA256_HEADER, request.headers) && this.applyChecksum) {\n      request.headers[SHA256_HEADER] = payloadHash;\n    }\n\n    const canonicalHeaders = getCanonicalHeaders(request, unsignableHeaders, signableHeaders);\n    const signature = await this.getSignature(\n      longDate,\n      scope,\n      this.getSigningKey(credentials, region, shortDate, signingService),\n      this.createCanonicalRequest(request, canonicalHeaders, payloadHash)\n    );\n\n    request.headers[AUTH_HEADER] =\n      `${ALGORITHM_IDENTIFIER} ` +\n      `Credential=${credentials.accessKeyId}/${scope}, ` +\n      `SignedHeaders=${getCanonicalHeaderList(canonicalHeaders)}, ` +\n      `Signature=${signature}`;\n\n    return request;\n  }\n\n  private createCanonicalRequest(request: HttpRequest, canonicalHeaders: HeaderBag, payloadHash: string): string {\n    const sortedHeaders = Object.keys(canonicalHeaders).sort();\n    return `${request.method}\n${this.getCanonicalPath(request)}\n${getCanonicalQuery(request)}\n${sortedHeaders.map((name) => `${name}:${canonicalHeaders[name]}`).join(\"\\n\")}\n\n${sortedHeaders.join(\";\")}\n${payloadHash}`;\n  }\n\n  private async createStringToSign(\n    longDate: string,\n    credentialScope: string,\n    canonicalRequest: string\n  ): Promise<string> {\n    const hash = new this.sha256();\n    hash.update(canonicalRequest);\n    const hashedRequest = await hash.digest();\n\n    return `${ALGORITHM_IDENTIFIER}\n${longDate}\n${credentialScope}\n${toHex(hashedRequest)}`;\n  }\n\n  private getCanonicalPath({ path }: HttpRequest): string {\n    if (this.uriEscapePath) {\n      const doubleEncoded = encodeURIComponent(path.replace(/^\\//, \"\"));\n      return `/${doubleEncoded.replace(/%2F/g, \"/\")}`;\n    }\n\n    return path;\n  }\n\n  private async getSignature(\n    longDate: string,\n    credentialScope: string,\n    keyPromise: Promise<Uint8Array>,\n    canonicalRequest: string\n  ): Promise<string> {\n    const stringToSign = await this.createStringToSign(longDate, credentialScope, canonicalRequest);\n\n    const hash = new this.sha256(await keyPromise);\n    hash.update(stringToSign);\n    return toHex(await hash.digest());\n  }\n\n  private getSigningKey(\n    credentials: Credentials,\n    region: string,\n    shortDate: string,\n    service?: string\n  ): Promise<Uint8Array> {\n    return getSigningKey(this.sha256, credentials, shortDate, region, service || this.service);\n  }\n}\n\nconst formatDate = (now: DateInput): { longDate: string; shortDate: string } => {\n  const longDate = iso8601(now).replace(/[\\-:]/g, \"\");\n  return {\n    longDate,\n    shortDate: longDate.substr(0, 8),\n  };\n};\n\nconst getCanonicalHeaderList = (headers: object): string => Object.keys(headers).sort().join(\";\");\n\nconst normalizeRegionProvider = (region: string | Provider<string>): Provider<string> => {\n  if (typeof region === \"string\") {\n    const promisified = Promise.resolve(region);\n    return () => promisified;\n  } else {\n    return region;\n  }\n};\n\nconst normalizeCredentialsProvider = (credentials: Credentials | Provider<Credentials>): Provider<Credentials> => {\n  if (typeof credentials === \"object\") {\n    const promisified = Promise.resolve(credentials);\n    return () => promisified;\n  } else {\n    return credentials;\n  }\n};\n"]},"metadata":{},"sourceType":"module"}