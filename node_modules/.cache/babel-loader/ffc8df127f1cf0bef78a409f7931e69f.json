{"ast":null,"code":"var __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nvar __spread = this && this.__spread || function () {\n  for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));\n\n  return ar;\n};\n\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n      m = s && o[s],\n      i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\n\nvar connectionTimeout = function (error) {\n  return /^Connection failed: Connection Timeout/.test(error.message);\n};\n\nvar serverError = function (error) {\n  return /^Error: Request failed with status code 5\\d\\d/.test(error.message);\n};\n\nexport var mutationErrorMap = {\n  BadModel: function () {\n    return false;\n  },\n  BadRecord: function (error) {\n    var message = error.message;\n    return /^Cannot return \\w+ for [\\w-_]+ type/.test(message) || /^Variable '.+' has coerced Null value for NonNull type/.test(message); // newly required field, out of date client\n  },\n  ConfigError: function () {\n    return false;\n  },\n  Transient: function (error) {\n    return connectionTimeout(error) || serverError(error);\n  },\n  Unauthorized: function (error) {\n    return /^Request failed with status code 401/.test(error.message);\n  }\n};\nexport var subscriptionErrorMap = {\n  BadModel: function () {\n    return false;\n  },\n  BadRecord: function () {\n    return false;\n  },\n  ConfigError: function () {\n    return false;\n  },\n  Transient: function (observableError) {\n    var error = unwrapObservableError(observableError);\n    return connectionTimeout(error) || serverError(error);\n  },\n  Unauthorized: function (observableError) {\n    var error = unwrapObservableError(observableError);\n    return /Connection failed.+Unauthorized/.test(error.message);\n  }\n};\nexport var syncErrorMap = {\n  BadModel: function () {\n    return false;\n  },\n  BadRecord: function (error) {\n    return /^Cannot return \\w+ for [\\w-_]+ type/.test(error.message);\n  },\n  ConfigError: function () {\n    return false;\n  },\n  Transient: function (error) {\n    return connectionTimeout(error) || serverError(error);\n  },\n  Unauthorized: function () {\n    return false;\n  }\n};\n/**\n * Get the first error reason of an observable.\n * Allows for error maps to be easily applied to observable errors\n *\n * @param observableError an error from ZenObservable subscribe error callback\n */\n\nfunction unwrapObservableError(observableError) {\n  var _a = observableError.error,\n      _b = __read((_a === void 0 ? {\n    errors: []\n  } : _a).errors, 1),\n      error = _b[0];\n\n  return error;\n}\n\nexport function getMutationErrorType(error) {\n  return mapErrorToType(mutationErrorMap, error);\n}\nexport function getSubscriptionErrorType(error) {\n  return mapErrorToType(subscriptionErrorMap, error);\n}\nexport function getSyncErrorType(error) {\n  return mapErrorToType(syncErrorMap, error);\n}\n/**\n * Categorizes an error with a broad error type, intended to make\n * customer error handling code simpler.\n * @param errorMap Error names and a list of patterns that indicate them (each pattern as a regex or function)\n * @param error The underying error to categorize.\n */\n\nexport function mapErrorToType(errorMap, error) {\n  var e_1, _a;\n\n  var errorTypes = __spread(Object.keys(errorMap));\n\n  try {\n    for (var errorTypes_1 = __values(errorTypes), errorTypes_1_1 = errorTypes_1.next(); !errorTypes_1_1.done; errorTypes_1_1 = errorTypes_1.next()) {\n      var errorType = errorTypes_1_1.value;\n      var matcher = errorMap[errorType];\n\n      if (matcher(error)) {\n        return errorType;\n      }\n    }\n  } catch (e_1_1) {\n    e_1 = {\n      error: e_1_1\n    };\n  } finally {\n    try {\n      if (errorTypes_1_1 && !errorTypes_1_1.done && (_a = errorTypes_1.return)) _a.call(errorTypes_1);\n    } finally {\n      if (e_1) throw e_1.error;\n    }\n  }\n\n  return 'Unknown';\n}","map":{"version":3,"mappings":"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","names":["connectionTimeout","test","error","message","serverError","mutationErrorMap","BadModel","BadRecord","ConfigError","Transient","Unauthorized","subscriptionErrorMap","unwrapObservableError","observableError","syncErrorMap","_b","getMutationErrorType","mapErrorToType","getSubscriptionErrorType","getSyncErrorType","errorMap","errorTypes","__spread","Object","keys","errorTypes_1_1","errorType","matcher"],"sources":["/Users/arnavmisra/Desktop/Portfolio-main/node_modules/@aws-amplify/datastore/src/sync/processors/errorMaps.ts"],"sourcesContent":["import { ErrorType } from '../../types';\n\nexport type ErrorMap = Partial<{\n\t[key in ErrorType]: (error: Error) => boolean;\n}>;\n\nconst connectionTimeout = error =>\n\t/^Connection failed: Connection Timeout/.test(error.message);\n\nconst serverError = error =>\n\t/^Error: Request failed with status code 5\\d\\d/.test(error.message);\n\nexport const mutationErrorMap: ErrorMap = {\n\tBadModel: () => false,\n\tBadRecord: error => {\n\t\tconst { message } = error;\n\t\treturn (\n\t\t\t/^Cannot return \\w+ for [\\w-_]+ type/.test(message) ||\n\t\t\t/^Variable '.+' has coerced Null value for NonNull type/.test(message)\n\t\t); // newly required field, out of date client\n\t},\n\tConfigError: () => false,\n\tTransient: error => connectionTimeout(error) || serverError(error),\n\tUnauthorized: error =>\n\t\t/^Request failed with status code 401/.test(error.message),\n};\n\nexport const subscriptionErrorMap: ErrorMap = {\n\tBadModel: () => false,\n\tBadRecord: () => false,\n\tConfigError: () => false,\n\tTransient: observableError => {\n\t\tconst error = unwrapObservableError(observableError);\n\t\treturn connectionTimeout(error) || serverError(error);\n\t},\n\tUnauthorized: observableError => {\n\t\tconst error = unwrapObservableError(observableError);\n\t\treturn /Connection failed.+Unauthorized/.test(error.message);\n\t},\n};\n\nexport const syncErrorMap: ErrorMap = {\n\tBadModel: () => false,\n\tBadRecord: error => /^Cannot return \\w+ for [\\w-_]+ type/.test(error.message),\n\tConfigError: () => false,\n\tTransient: error => connectionTimeout(error) || serverError(error),\n\tUnauthorized: () => false,\n};\n\n/**\n * Get the first error reason of an observable.\n * Allows for error maps to be easily applied to observable errors\n *\n * @param observableError an error from ZenObservable subscribe error callback\n */\nfunction unwrapObservableError(observableError: any) {\n\tconst {\n\t\terror: { errors: [error] } = {\n\t\t\terrors: [],\n\t\t},\n\t} = observableError;\n\n\treturn error;\n}\n\nexport function getMutationErrorType(error: Error): ErrorType {\n\treturn mapErrorToType(mutationErrorMap, error);\n}\n\nexport function getSubscriptionErrorType(error: Error): ErrorType {\n\treturn mapErrorToType(subscriptionErrorMap, error);\n}\n\nexport function getSyncErrorType(error: Error): ErrorType {\n\treturn mapErrorToType(syncErrorMap, error);\n}\n\n/**\n * Categorizes an error with a broad error type, intended to make\n * customer error handling code simpler.\n * @param errorMap Error names and a list of patterns that indicate them (each pattern as a regex or function)\n * @param error The underying error to categorize.\n */\nexport function mapErrorToType(errorMap: ErrorMap, error: Error): ErrorType {\n\tconst errorTypes = [...Object.keys(errorMap)] as ErrorType[];\n\tfor (const errorType of errorTypes) {\n\t\tconst matcher = errorMap[errorType];\n\t\tif (matcher(error)) {\n\t\t\treturn errorType;\n\t\t}\n\t}\n\treturn 'Unknown';\n}\n"]},"metadata":{},"sourceType":"module"}